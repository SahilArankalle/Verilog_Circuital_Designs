// Copyright (C) 2020  Intel Corporation. All rights reserved.
// Your use of Intel Corporation's design tools, logic functions 
// and other software and tools, and any partner logic 
// functions, and any output files from any of the foregoing 
// (including device programming or simulation files), and any 
// associated documentation or information are expressly subject 
// to the terms and conditions of the Intel Program License 
// Subscription Agreement, the Intel Quartus Prime License Agreement,
// the Intel FPGA IP License Agreement, or other applicable license
// agreement, including, without limitation, that your use is for
// the sole purpose of programming logic devices manufactured by
// Intel and sold by Intel or its authorized distributors.  Please
// refer to the applicable agreement for further details, at
// https://fpgasoftware.intel.com/eula.

// VENDOR "Altera"
// PROGRAM "Quartus Prime"
// VERSION "Version 20.1.1 Build 720 11/11/2020 SJ Lite Edition"

// DATE "10/27/2024 15:24:27"

// 
// Device: Altera 5M240ZM100C4 Package MBGA100
// 

// 
// This Verilog file should be used for ModelSim-Altera (Verilog) only
// 

`timescale 1 ps/ 1 ps

module ram8x16_asynch_dualport (
	wr_clk,
	rd_clk,
	clr,
	we,
	re,
	data_in,
	rd_addr,
	wr_addr,
	data_out);
input 	wr_clk;
input 	rd_clk;
input 	clr;
input 	we;
input 	re;
input 	[15:0] data_in;
input 	[2:0] rd_addr;
input 	[2:0] wr_addr;
output 	[15:0] data_out;

// Design Ports Information


wire gnd;
wire vcc;
wire unknown;

assign gnd = 1'b0;
assign vcc = 1'b1;
assign unknown = 1'bx;

tri1 devclrn;
tri1 devpor;
tri1 devoe;
wire \mem[6][0]~regout ;
wire \mem[5][0]~regout ;
wire \mem[1][0]~regout ;
wire \mem[2][0]~regout ;
wire \mem[6][1]~regout ;
wire \mem[5][1]~regout ;
wire \mem[1][1]~regout ;
wire \mem[2][1]~regout ;
wire \mem[6][2]~regout ;
wire \mem[5][2]~regout ;
wire \mem[1][2]~regout ;
wire \mem[2][2]~regout ;
wire \mem[6][3]~regout ;
wire \mem[5][3]~regout ;
wire \mem[1][3]~regout ;
wire \mem[2][3]~regout ;
wire \mem[6][4]~regout ;
wire \mem[5][4]~regout ;
wire \mem[1][4]~regout ;
wire \mem[2][4]~regout ;
wire \mem[6][5]~regout ;
wire \mem[5][5]~regout ;
wire \mem[1][5]~regout ;
wire \mem[2][5]~regout ;
wire \mem[6][6]~regout ;
wire \mem[5][6]~regout ;
wire \mem[1][6]~regout ;
wire \mem[2][6]~regout ;
wire \mem[6][7]~regout ;
wire \mem[5][7]~regout ;
wire \mem[1][7]~regout ;
wire \mem[2][7]~regout ;
wire \mem[6][8]~regout ;
wire \mem[5][8]~regout ;
wire \mem[1][8]~regout ;
wire \mem[2][8]~regout ;
wire \mem[6][9]~regout ;
wire \mem[5][9]~regout ;
wire \mem[1][9]~regout ;
wire \mem[2][9]~regout ;
wire \mem[6][10]~regout ;
wire \mem[5][10]~regout ;
wire \mem[1][10]~regout ;
wire \mem[2][10]~regout ;
wire \mem[6][11]~regout ;
wire \mem[5][11]~regout ;
wire \mem[1][11]~regout ;
wire \mem[2][11]~regout ;
wire \mem[6][12]~regout ;
wire \mem[5][12]~regout ;
wire \mem[1][12]~regout ;
wire \mem[2][12]~regout ;
wire \mem[6][13]~regout ;
wire \mem[5][13]~regout ;
wire \mem[1][13]~regout ;
wire \mem[2][13]~regout ;
wire \mem[6][14]~regout ;
wire \mem[5][14]~regout ;
wire \mem[1][14]~regout ;
wire \mem[2][14]~regout ;
wire \mem[6][15]~regout ;
wire \mem[5][15]~regout ;
wire \mem[1][15]~regout ;
wire \mem[2][15]~regout ;
wire \rd_clk~combout ;
wire \wr_clk~combout ;
wire \clr~combout ;
wire \we~combout ;
wire \Decoder0~3_combout ;
wire \mem[7][0]~regout ;
wire \Decoder0~2_combout ;
wire \mem[4][0]~regout ;
wire \Decoder0~1_combout ;
wire \Mux15~0 ;
wire \Decoder0~0_combout ;
wire \Mux15~1 ;
wire \Decoder0~7_combout ;
wire \mem[3][0]~regout ;
wire \Decoder0~6_combout ;
wire \mem[0][0]~regout ;
wire \Decoder0~5_combout ;
wire \Mux15~2 ;
wire \Decoder0~4_combout ;
wire \Mux15~3 ;
wire \re~combout ;
wire \data_out[0]~reg0_regout ;
wire \mem[7][1]~regout ;
wire \mem[4][1]~regout ;
wire \Mux14~0 ;
wire \Mux14~1 ;
wire \mem[3][1]~regout ;
wire \mem[0][1]~regout ;
wire \Mux14~2 ;
wire \Mux14~3 ;
wire \data_out[1]~reg0_regout ;
wire \mem[7][2]~regout ;
wire \mem[4][2]~regout ;
wire \Mux13~0 ;
wire \Mux13~1 ;
wire \mem[3][2]~regout ;
wire \mem[0][2]~regout ;
wire \Mux13~2 ;
wire \Mux13~3 ;
wire \data_out[2]~reg0_regout ;
wire \mem[7][3]~regout ;
wire \mem[4][3]~regout ;
wire \Mux12~0 ;
wire \Mux12~1 ;
wire \mem[3][3]~regout ;
wire \mem[0][3]~regout ;
wire \Mux12~2 ;
wire \Mux12~3 ;
wire \data_out[3]~reg0_regout ;
wire \mem[3][4]~regout ;
wire \mem[0][4]~regout ;
wire \Mux11~2 ;
wire \Mux11~3 ;
wire \mem[7][4]~regout ;
wire \mem[4][4]~regout ;
wire \Mux11~0 ;
wire \Mux11~1 ;
wire \data_out[4]~reg0_regout ;
wire \mem[7][5]~regout ;
wire \mem[4][5]~regout ;
wire \Mux10~0 ;
wire \Mux10~1 ;
wire \mem[3][5]~regout ;
wire \mem[0][5]~regout ;
wire \Mux10~2 ;
wire \Mux10~3 ;
wire \data_out[5]~reg0_regout ;
wire \mem[7][6]~regout ;
wire \mem[4][6]~regout ;
wire \Mux9~0 ;
wire \Mux9~1 ;
wire \mem[3][6]~regout ;
wire \mem[0][6]~regout ;
wire \Mux9~2 ;
wire \Mux9~3 ;
wire \data_out[6]~reg0_regout ;
wire \mem[7][7]~regout ;
wire \mem[4][7]~regout ;
wire \Mux8~0 ;
wire \Mux8~1 ;
wire \mem[3][7]~regout ;
wire \mem[0][7]~regout ;
wire \Mux8~2 ;
wire \Mux8~3 ;
wire \data_out[7]~reg0_regout ;
wire \mem[3][8]~regout ;
wire \mem[0][8]~regout ;
wire \Mux7~2 ;
wire \Mux7~3 ;
wire \mem[7][8]~regout ;
wire \mem[4][8]~regout ;
wire \Mux7~0 ;
wire \Mux7~1 ;
wire \data_out[8]~reg0_regout ;
wire \mem[3][9]~regout ;
wire \mem[0][9]~regout ;
wire \Mux6~2 ;
wire \Mux6~3 ;
wire \mem[7][9]~regout ;
wire \mem[4][9]~regout ;
wire \Mux6~0 ;
wire \Mux6~1 ;
wire \data_out[9]~reg0_regout ;
wire \mem[7][10]~regout ;
wire \mem[4][10]~regout ;
wire \Mux5~0 ;
wire \Mux5~1 ;
wire \mem[3][10]~regout ;
wire \mem[0][10]~regout ;
wire \Mux5~2 ;
wire \Mux5~3 ;
wire \data_out[10]~reg0_regout ;
wire \mem[7][11]~regout ;
wire \mem[4][11]~regout ;
wire \Mux4~0 ;
wire \Mux4~1 ;
wire \mem[3][11]~regout ;
wire \mem[0][11]~regout ;
wire \Mux4~2 ;
wire \Mux4~3 ;
wire \data_out[11]~reg0_regout ;
wire \mem[7][12]~regout ;
wire \mem[4][12]~regout ;
wire \Mux3~0 ;
wire \Mux3~1 ;
wire \mem[3][12]~regout ;
wire \mem[0][12]~regout ;
wire \Mux3~2 ;
wire \Mux3~3 ;
wire \data_out[12]~reg0_regout ;
wire \mem[7][13]~regout ;
wire \mem[4][13]~regout ;
wire \Mux2~0 ;
wire \Mux2~1 ;
wire \mem[0][13]~regout ;
wire \Mux2~2 ;
wire \mem[3][13]~regout ;
wire \Mux2~3 ;
wire \data_out[13]~reg0_regout ;
wire \mem[7][14]~regout ;
wire \mem[4][14]~regout ;
wire \Mux1~0 ;
wire \Mux1~1 ;
wire \mem[3][14]~regout ;
wire \mem[0][14]~regout ;
wire \Mux1~2 ;
wire \Mux1~3 ;
wire \data_out[14]~reg0_regout ;
wire \mem[7][15]~regout ;
wire \mem[4][15]~regout ;
wire \Mux0~0 ;
wire \Mux0~1 ;
wire \mem[3][15]~regout ;
wire \mem[0][15]~regout ;
wire \Mux0~2 ;
wire \Mux0~3 ;
wire \data_out[15]~reg0_regout ;
wire [2:0] \rd_addr~combout ;
wire [15:0] \data_in~combout ;
wire [2:0] \wr_addr~combout ;


// Location: PIN_F2,	 I/O Standard: 3.3-V LVTTL,	 Current Strength: Default
maxv_io \rd_clk~I (
	.datain(gnd),
	.oe(gnd),
	.combout(\rd_clk~combout ),
	.padio(rd_clk));
// synopsys translate_off
defparam \rd_clk~I .operation_mode = "input";
// synopsys translate_on

// Location: PIN_C6,	 I/O Standard: 3.3-V LVTTL,	 Current Strength: Default
maxv_io \rd_addr[2]~I (
	.datain(gnd),
	.oe(gnd),
	.combout(\rd_addr~combout [2]),
	.padio(rd_addr[2]));
// synopsys translate_off
defparam \rd_addr[2]~I .operation_mode = "input";
// synopsys translate_on

// Location: PIN_E1,	 I/O Standard: 3.3-V LVTTL,	 Current Strength: Default
maxv_io \wr_clk~I (
	.datain(gnd),
	.oe(gnd),
	.combout(\wr_clk~combout ),
	.padio(wr_clk));
// synopsys translate_off
defparam \wr_clk~I .operation_mode = "input";
// synopsys translate_on

// Location: PIN_C2,	 I/O Standard: 3.3-V LVTTL,	 Current Strength: Default
maxv_io \rd_addr[0]~I (
	.datain(gnd),
	.oe(gnd),
	.combout(\rd_addr~combout [0]),
	.padio(rd_addr[0]));
// synopsys translate_off
defparam \rd_addr[0]~I .operation_mode = "input";
// synopsys translate_on

// Location: PIN_C10,	 I/O Standard: 3.3-V LVTTL,	 Current Strength: Default
maxv_io \data_in[0]~I (
	.datain(gnd),
	.oe(gnd),
	.combout(\data_in~combout [0]),
	.padio(data_in[0]));
// synopsys translate_off
defparam \data_in[0]~I .operation_mode = "input";
// synopsys translate_on

// Location: PIN_F10,	 I/O Standard: 3.3-V LVTTL,	 Current Strength: Default
maxv_io \clr~I (
	.datain(gnd),
	.oe(gnd),
	.combout(\clr~combout ),
	.padio(clr));
// synopsys translate_off
defparam \clr~I .operation_mode = "input";
// synopsys translate_on

// Location: PIN_F11,	 I/O Standard: 3.3-V LVTTL,	 Current Strength: Default
maxv_io \wr_addr[0]~I (
	.datain(gnd),
	.oe(gnd),
	.combout(\wr_addr~combout [0]),
	.padio(wr_addr[0]));
// synopsys translate_off
defparam \wr_addr[0]~I .operation_mode = "input";
// synopsys translate_on

// Location: PIN_J10,	 I/O Standard: 3.3-V LVTTL,	 Current Strength: Default
maxv_io \wr_addr[1]~I (
	.datain(gnd),
	.oe(gnd),
	.combout(\wr_addr~combout [1]),
	.padio(wr_addr[1]));
// synopsys translate_off
defparam \wr_addr[1]~I .operation_mode = "input";
// synopsys translate_on

// Location: PIN_E11,	 I/O Standard: 3.3-V LVTTL,	 Current Strength: Default
maxv_io \we~I (
	.datain(gnd),
	.oe(gnd),
	.combout(\we~combout ),
	.padio(we));
// synopsys translate_off
defparam \we~I .operation_mode = "input";
// synopsys translate_on

// Location: PIN_G11,	 I/O Standard: 3.3-V LVTTL,	 Current Strength: Default
maxv_io \wr_addr[2]~I (
	.datain(gnd),
	.oe(gnd),
	.combout(\wr_addr~combout [2]),
	.padio(wr_addr[2]));
// synopsys translate_off
defparam \wr_addr[2]~I .operation_mode = "input";
// synopsys translate_on

// Location: LC_X7_Y3_N0
maxv_lcell \Decoder0~3 (
// Equation(s):
// \Decoder0~3_combout  = (\wr_addr~combout [0] & (\wr_addr~combout [1] & (\we~combout  & \wr_addr~combout [2])))

	.clk(gnd),
	.dataa(\wr_addr~combout [0]),
	.datab(\wr_addr~combout [1]),
	.datac(\we~combout ),
	.datad(\wr_addr~combout [2]),
	.aclr(gnd),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(vcc),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(\Decoder0~3_combout ),
	.regout(),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \Decoder0~3 .lut_mask = "8000";
defparam \Decoder0~3 .operation_mode = "normal";
defparam \Decoder0~3 .output_mode = "comb_only";
defparam \Decoder0~3 .register_cascade_mode = "off";
defparam \Decoder0~3 .sum_lutc_input = "datac";
defparam \Decoder0~3 .synch_mode = "off";
// synopsys translate_on

// Location: LC_X3_Y3_N9
maxv_lcell \mem[7][0] (
// Equation(s):
// \mem[7][0]~regout  = DFFEAS(GND, GLOBAL(\wr_clk~combout ), !GLOBAL(\clr~combout ), , \Decoder0~3_combout , \data_in~combout [0], , , VCC)

	.clk(\wr_clk~combout ),
	.dataa(vcc),
	.datab(vcc),
	.datac(\data_in~combout [0]),
	.datad(vcc),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~3_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\mem[7][0]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[7][0] .lut_mask = "0000";
defparam \mem[7][0] .operation_mode = "normal";
defparam \mem[7][0] .output_mode = "reg_only";
defparam \mem[7][0] .register_cascade_mode = "off";
defparam \mem[7][0] .sum_lutc_input = "datac";
defparam \mem[7][0] .synch_mode = "on";
// synopsys translate_on

// Location: PIN_G2,	 I/O Standard: 3.3-V LVTTL,	 Current Strength: Default
maxv_io \rd_addr[1]~I (
	.datain(gnd),
	.oe(gnd),
	.combout(\rd_addr~combout [1]),
	.padio(rd_addr[1]));
// synopsys translate_off
defparam \rd_addr[1]~I .operation_mode = "input";
// synopsys translate_on

// Location: LC_X7_Y3_N2
maxv_lcell \Decoder0~2 (
// Equation(s):
// \Decoder0~2_combout  = (!\wr_addr~combout [0] & (!\wr_addr~combout [1] & (\we~combout  & \wr_addr~combout [2])))

	.clk(gnd),
	.dataa(\wr_addr~combout [0]),
	.datab(\wr_addr~combout [1]),
	.datac(\we~combout ),
	.datad(\wr_addr~combout [2]),
	.aclr(gnd),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(vcc),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(\Decoder0~2_combout ),
	.regout(),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \Decoder0~2 .lut_mask = "1000";
defparam \Decoder0~2 .operation_mode = "normal";
defparam \Decoder0~2 .output_mode = "comb_only";
defparam \Decoder0~2 .register_cascade_mode = "off";
defparam \Decoder0~2 .sum_lutc_input = "datac";
defparam \Decoder0~2 .synch_mode = "off";
// synopsys translate_on

// Location: LC_X3_Y3_N5
maxv_lcell \mem[4][0] (
// Equation(s):
// \mem[4][0]~regout  = DFFEAS(GND, GLOBAL(\wr_clk~combout ), !GLOBAL(\clr~combout ), , \Decoder0~2_combout , \data_in~combout [0], , , VCC)

	.clk(\wr_clk~combout ),
	.dataa(vcc),
	.datab(vcc),
	.datac(\data_in~combout [0]),
	.datad(vcc),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~2_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\mem[4][0]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[4][0] .lut_mask = "0000";
defparam \mem[4][0] .operation_mode = "normal";
defparam \mem[4][0] .output_mode = "reg_only";
defparam \mem[4][0] .register_cascade_mode = "off";
defparam \mem[4][0] .sum_lutc_input = "datac";
defparam \mem[4][0] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X7_Y3_N4
maxv_lcell \Decoder0~1 (
// Equation(s):
// \Decoder0~1_combout  = (!\wr_addr~combout [0] & (\wr_addr~combout [1] & (\we~combout  & \wr_addr~combout [2])))

	.clk(gnd),
	.dataa(\wr_addr~combout [0]),
	.datab(\wr_addr~combout [1]),
	.datac(\we~combout ),
	.datad(\wr_addr~combout [2]),
	.aclr(gnd),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(vcc),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(\Decoder0~1_combout ),
	.regout(),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \Decoder0~1 .lut_mask = "4000";
defparam \Decoder0~1 .operation_mode = "normal";
defparam \Decoder0~1 .output_mode = "comb_only";
defparam \Decoder0~1 .register_cascade_mode = "off";
defparam \Decoder0~1 .sum_lutc_input = "datac";
defparam \Decoder0~1 .synch_mode = "off";
// synopsys translate_on

// Location: LC_X4_Y3_N0
maxv_lcell \mem[6][0] (
// Equation(s):
// \Mux15~0  = (\rd_addr~combout [0] & (\rd_addr~combout [1])) # (!\rd_addr~combout [0] & ((\rd_addr~combout [1] & (mem[6][0])) # (!\rd_addr~combout [1] & ((\mem[4][0]~regout )))))

	.clk(\wr_clk~combout ),
	.dataa(\rd_addr~combout [0]),
	.datab(\rd_addr~combout [1]),
	.datac(\data_in~combout [0]),
	.datad(\mem[4][0]~regout ),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~1_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(\Mux15~0 ),
	.regout(\mem[6][0]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[6][0] .lut_mask = "d9c8";
defparam \mem[6][0] .operation_mode = "normal";
defparam \mem[6][0] .output_mode = "comb_only";
defparam \mem[6][0] .register_cascade_mode = "off";
defparam \mem[6][0] .sum_lutc_input = "qfbk";
defparam \mem[6][0] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X7_Y3_N5
maxv_lcell \Decoder0~0 (
// Equation(s):
// \Decoder0~0_combout  = (\wr_addr~combout [0] & (!\wr_addr~combout [1] & (\we~combout  & \wr_addr~combout [2])))

	.clk(gnd),
	.dataa(\wr_addr~combout [0]),
	.datab(\wr_addr~combout [1]),
	.datac(\we~combout ),
	.datad(\wr_addr~combout [2]),
	.aclr(gnd),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(vcc),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(\Decoder0~0_combout ),
	.regout(),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \Decoder0~0 .lut_mask = "2000";
defparam \Decoder0~0 .operation_mode = "normal";
defparam \Decoder0~0 .output_mode = "comb_only";
defparam \Decoder0~0 .register_cascade_mode = "off";
defparam \Decoder0~0 .sum_lutc_input = "datac";
defparam \Decoder0~0 .synch_mode = "off";
// synopsys translate_on

// Location: LC_X4_Y3_N1
maxv_lcell \mem[5][0] (
// Equation(s):
// \Mux15~1  = (\rd_addr~combout [0] & ((\Mux15~0  & (\mem[7][0]~regout )) # (!\Mux15~0  & ((mem[5][0]))))) # (!\rd_addr~combout [0] & (((\Mux15~0 ))))

	.clk(\wr_clk~combout ),
	.dataa(\rd_addr~combout [0]),
	.datab(\mem[7][0]~regout ),
	.datac(\data_in~combout [0]),
	.datad(\Mux15~0 ),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~0_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(\Mux15~1 ),
	.regout(\mem[5][0]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[5][0] .lut_mask = "dda0";
defparam \mem[5][0] .operation_mode = "normal";
defparam \mem[5][0] .output_mode = "comb_only";
defparam \mem[5][0] .register_cascade_mode = "off";
defparam \mem[5][0] .sum_lutc_input = "qfbk";
defparam \mem[5][0] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X7_Y3_N1
maxv_lcell \Decoder0~7 (
// Equation(s):
// \Decoder0~7_combout  = (\wr_addr~combout [0] & (\wr_addr~combout [1] & (\we~combout  & !\wr_addr~combout [2])))

	.clk(gnd),
	.dataa(\wr_addr~combout [0]),
	.datab(\wr_addr~combout [1]),
	.datac(\we~combout ),
	.datad(\wr_addr~combout [2]),
	.aclr(gnd),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(vcc),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(\Decoder0~7_combout ),
	.regout(),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \Decoder0~7 .lut_mask = "0080";
defparam \Decoder0~7 .operation_mode = "normal";
defparam \Decoder0~7 .output_mode = "comb_only";
defparam \Decoder0~7 .register_cascade_mode = "off";
defparam \Decoder0~7 .sum_lutc_input = "datac";
defparam \Decoder0~7 .synch_mode = "off";
// synopsys translate_on

// Location: LC_X6_Y4_N8
maxv_lcell \mem[3][0] (
// Equation(s):
// \mem[3][0]~regout  = DFFEAS(GND, GLOBAL(\wr_clk~combout ), !GLOBAL(\clr~combout ), , \Decoder0~7_combout , \data_in~combout [0], , , VCC)

	.clk(\wr_clk~combout ),
	.dataa(vcc),
	.datab(vcc),
	.datac(\data_in~combout [0]),
	.datad(vcc),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~7_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\mem[3][0]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[3][0] .lut_mask = "0000";
defparam \mem[3][0] .operation_mode = "normal";
defparam \mem[3][0] .output_mode = "reg_only";
defparam \mem[3][0] .register_cascade_mode = "off";
defparam \mem[3][0] .sum_lutc_input = "datac";
defparam \mem[3][0] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X7_Y3_N9
maxv_lcell \Decoder0~6 (
// Equation(s):
// \Decoder0~6_combout  = (!\wr_addr~combout [0] & (!\wr_addr~combout [1] & (\we~combout  & !\wr_addr~combout [2])))

	.clk(gnd),
	.dataa(\wr_addr~combout [0]),
	.datab(\wr_addr~combout [1]),
	.datac(\we~combout ),
	.datad(\wr_addr~combout [2]),
	.aclr(gnd),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(vcc),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(\Decoder0~6_combout ),
	.regout(),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \Decoder0~6 .lut_mask = "0010";
defparam \Decoder0~6 .operation_mode = "normal";
defparam \Decoder0~6 .output_mode = "comb_only";
defparam \Decoder0~6 .register_cascade_mode = "off";
defparam \Decoder0~6 .sum_lutc_input = "datac";
defparam \Decoder0~6 .synch_mode = "off";
// synopsys translate_on

// Location: LC_X7_Y2_N1
maxv_lcell \mem[0][0] (
// Equation(s):
// \mem[0][0]~regout  = DFFEAS(GND, GLOBAL(\wr_clk~combout ), !GLOBAL(\clr~combout ), , \Decoder0~6_combout , \data_in~combout [0], , , VCC)

	.clk(\wr_clk~combout ),
	.dataa(vcc),
	.datab(vcc),
	.datac(\data_in~combout [0]),
	.datad(vcc),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~6_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\mem[0][0]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[0][0] .lut_mask = "0000";
defparam \mem[0][0] .operation_mode = "normal";
defparam \mem[0][0] .output_mode = "reg_only";
defparam \mem[0][0] .register_cascade_mode = "off";
defparam \mem[0][0] .sum_lutc_input = "datac";
defparam \mem[0][0] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X7_Y3_N3
maxv_lcell \Decoder0~5 (
// Equation(s):
// \Decoder0~5_combout  = (\wr_addr~combout [0] & (!\wr_addr~combout [1] & (\we~combout  & !\wr_addr~combout [2])))

	.clk(gnd),
	.dataa(\wr_addr~combout [0]),
	.datab(\wr_addr~combout [1]),
	.datac(\we~combout ),
	.datad(\wr_addr~combout [2]),
	.aclr(gnd),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(vcc),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(\Decoder0~5_combout ),
	.regout(),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \Decoder0~5 .lut_mask = "0020";
defparam \Decoder0~5 .operation_mode = "normal";
defparam \Decoder0~5 .output_mode = "comb_only";
defparam \Decoder0~5 .register_cascade_mode = "off";
defparam \Decoder0~5 .sum_lutc_input = "datac";
defparam \Decoder0~5 .synch_mode = "off";
// synopsys translate_on

// Location: LC_X6_Y2_N8
maxv_lcell \mem[1][0] (
// Equation(s):
// \Mux15~2  = (\rd_addr~combout [1] & (\rd_addr~combout [0])) # (!\rd_addr~combout [1] & ((\rd_addr~combout [0] & (mem[1][0])) # (!\rd_addr~combout [0] & ((\mem[0][0]~regout )))))

	.clk(\wr_clk~combout ),
	.dataa(\rd_addr~combout [1]),
	.datab(\rd_addr~combout [0]),
	.datac(\data_in~combout [0]),
	.datad(\mem[0][0]~regout ),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~5_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(\Mux15~2 ),
	.regout(\mem[1][0]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[1][0] .lut_mask = "d9c8";
defparam \mem[1][0] .operation_mode = "normal";
defparam \mem[1][0] .output_mode = "comb_only";
defparam \mem[1][0] .register_cascade_mode = "off";
defparam \mem[1][0] .sum_lutc_input = "qfbk";
defparam \mem[1][0] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X7_Y3_N7
maxv_lcell \Decoder0~4 (
// Equation(s):
// \Decoder0~4_combout  = (!\wr_addr~combout [0] & (\wr_addr~combout [1] & (\we~combout  & !\wr_addr~combout [2])))

	.clk(gnd),
	.dataa(\wr_addr~combout [0]),
	.datab(\wr_addr~combout [1]),
	.datac(\we~combout ),
	.datad(\wr_addr~combout [2]),
	.aclr(gnd),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(vcc),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(\Decoder0~4_combout ),
	.regout(),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \Decoder0~4 .lut_mask = "0040";
defparam \Decoder0~4 .operation_mode = "normal";
defparam \Decoder0~4 .output_mode = "comb_only";
defparam \Decoder0~4 .register_cascade_mode = "off";
defparam \Decoder0~4 .sum_lutc_input = "datac";
defparam \Decoder0~4 .synch_mode = "off";
// synopsys translate_on

// Location: LC_X5_Y3_N6
maxv_lcell \mem[2][0] (
// Equation(s):
// \Mux15~3  = (\rd_addr~combout [1] & ((\Mux15~2  & (\mem[3][0]~regout )) # (!\Mux15~2  & ((mem[2][0]))))) # (!\rd_addr~combout [1] & (((\Mux15~2 ))))

	.clk(\wr_clk~combout ),
	.dataa(\mem[3][0]~regout ),
	.datab(\rd_addr~combout [1]),
	.datac(\data_in~combout [0]),
	.datad(\Mux15~2 ),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~4_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(\Mux15~3 ),
	.regout(\mem[2][0]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[2][0] .lut_mask = "bbc0";
defparam \mem[2][0] .operation_mode = "normal";
defparam \mem[2][0] .output_mode = "comb_only";
defparam \mem[2][0] .register_cascade_mode = "off";
defparam \mem[2][0] .sum_lutc_input = "qfbk";
defparam \mem[2][0] .synch_mode = "on";
// synopsys translate_on

// Location: PIN_L7,	 I/O Standard: 3.3-V LVTTL,	 Current Strength: Default
maxv_io \re~I (
	.datain(gnd),
	.oe(gnd),
	.combout(\re~combout ),
	.padio(re));
// synopsys translate_off
defparam \re~I .operation_mode = "input";
// synopsys translate_on

// Location: LC_X5_Y3_N7
maxv_lcell \data_out[0]~reg0 (
// Equation(s):
// \data_out[0]~reg0_regout  = DFFEAS((\rd_addr~combout [2] & (((\Mux15~1 )))) # (!\rd_addr~combout [2] & (((\Mux15~3 )))), GLOBAL(\rd_clk~combout ), !GLOBAL(\clr~combout ), , \re~combout , , , , )

	.clk(\rd_clk~combout ),
	.dataa(\rd_addr~combout [2]),
	.datab(vcc),
	.datac(\Mux15~1 ),
	.datad(\Mux15~3 ),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(\re~combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\data_out[0]~reg0_regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \data_out[0]~reg0 .lut_mask = "f5a0";
defparam \data_out[0]~reg0 .operation_mode = "normal";
defparam \data_out[0]~reg0 .output_mode = "reg_only";
defparam \data_out[0]~reg0 .register_cascade_mode = "off";
defparam \data_out[0]~reg0 .sum_lutc_input = "datac";
defparam \data_out[0]~reg0 .synch_mode = "off";
// synopsys translate_on

// Location: PIN_K4,	 I/O Standard: 3.3-V LVTTL,	 Current Strength: Default
maxv_io \data_in[1]~I (
	.datain(gnd),
	.oe(gnd),
	.combout(\data_in~combout [1]),
	.padio(data_in[1]));
// synopsys translate_off
defparam \data_in[1]~I .operation_mode = "input";
// synopsys translate_on

// Location: LC_X3_Y3_N8
maxv_lcell \mem[7][1] (
// Equation(s):
// \mem[7][1]~regout  = DFFEAS(GND, GLOBAL(\wr_clk~combout ), !GLOBAL(\clr~combout ), , \Decoder0~3_combout , \data_in~combout [1], , , VCC)

	.clk(\wr_clk~combout ),
	.dataa(vcc),
	.datab(vcc),
	.datac(\data_in~combout [1]),
	.datad(vcc),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~3_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\mem[7][1]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[7][1] .lut_mask = "0000";
defparam \mem[7][1] .operation_mode = "normal";
defparam \mem[7][1] .output_mode = "reg_only";
defparam \mem[7][1] .register_cascade_mode = "off";
defparam \mem[7][1] .sum_lutc_input = "datac";
defparam \mem[7][1] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X3_Y3_N2
maxv_lcell \mem[4][1] (
// Equation(s):
// \mem[4][1]~regout  = DFFEAS(GND, GLOBAL(\wr_clk~combout ), !GLOBAL(\clr~combout ), , \Decoder0~2_combout , \data_in~combout [1], , , VCC)

	.clk(\wr_clk~combout ),
	.dataa(vcc),
	.datab(vcc),
	.datac(\data_in~combout [1]),
	.datad(vcc),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~2_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\mem[4][1]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[4][1] .lut_mask = "0000";
defparam \mem[4][1] .operation_mode = "normal";
defparam \mem[4][1] .output_mode = "reg_only";
defparam \mem[4][1] .register_cascade_mode = "off";
defparam \mem[4][1] .sum_lutc_input = "datac";
defparam \mem[4][1] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X4_Y3_N5
maxv_lcell \mem[6][1] (
// Equation(s):
// \Mux14~0  = (\rd_addr~combout [1] & ((\rd_addr~combout [0]) # ((mem[6][1])))) # (!\rd_addr~combout [1] & (!\rd_addr~combout [0] & ((\mem[4][1]~regout ))))

	.clk(\wr_clk~combout ),
	.dataa(\rd_addr~combout [1]),
	.datab(\rd_addr~combout [0]),
	.datac(\data_in~combout [1]),
	.datad(\mem[4][1]~regout ),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~1_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(\Mux14~0 ),
	.regout(\mem[6][1]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[6][1] .lut_mask = "b9a8";
defparam \mem[6][1] .operation_mode = "normal";
defparam \mem[6][1] .output_mode = "comb_only";
defparam \mem[6][1] .register_cascade_mode = "off";
defparam \mem[6][1] .sum_lutc_input = "qfbk";
defparam \mem[6][1] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X4_Y3_N6
maxv_lcell \mem[5][1] (
// Equation(s):
// \Mux14~1  = (\rd_addr~combout [0] & ((\Mux14~0  & (\mem[7][1]~regout )) # (!\Mux14~0  & ((mem[5][1]))))) # (!\rd_addr~combout [0] & (((\Mux14~0 ))))

	.clk(\wr_clk~combout ),
	.dataa(\rd_addr~combout [0]),
	.datab(\mem[7][1]~regout ),
	.datac(\data_in~combout [1]),
	.datad(\Mux14~0 ),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~0_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(\Mux14~1 ),
	.regout(\mem[5][1]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[5][1] .lut_mask = "dda0";
defparam \mem[5][1] .operation_mode = "normal";
defparam \mem[5][1] .output_mode = "comb_only";
defparam \mem[5][1] .register_cascade_mode = "off";
defparam \mem[5][1] .sum_lutc_input = "qfbk";
defparam \mem[5][1] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X6_Y4_N6
maxv_lcell \mem[3][1] (
// Equation(s):
// \mem[3][1]~regout  = DFFEAS(GND, GLOBAL(\wr_clk~combout ), !GLOBAL(\clr~combout ), , \Decoder0~7_combout , \data_in~combout [1], , , VCC)

	.clk(\wr_clk~combout ),
	.dataa(vcc),
	.datab(vcc),
	.datac(\data_in~combout [1]),
	.datad(vcc),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~7_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\mem[3][1]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[3][1] .lut_mask = "0000";
defparam \mem[3][1] .operation_mode = "normal";
defparam \mem[3][1] .output_mode = "reg_only";
defparam \mem[3][1] .register_cascade_mode = "off";
defparam \mem[3][1] .sum_lutc_input = "datac";
defparam \mem[3][1] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X6_Y1_N3
maxv_lcell \mem[0][1] (
// Equation(s):
// \mem[0][1]~regout  = DFFEAS(GND, GLOBAL(\wr_clk~combout ), !GLOBAL(\clr~combout ), , \Decoder0~6_combout , \data_in~combout [1], , , VCC)

	.clk(\wr_clk~combout ),
	.dataa(vcc),
	.datab(vcc),
	.datac(\data_in~combout [1]),
	.datad(vcc),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~6_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\mem[0][1]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[0][1] .lut_mask = "0000";
defparam \mem[0][1] .operation_mode = "normal";
defparam \mem[0][1] .output_mode = "reg_only";
defparam \mem[0][1] .register_cascade_mode = "off";
defparam \mem[0][1] .sum_lutc_input = "datac";
defparam \mem[0][1] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X6_Y1_N8
maxv_lcell \mem[1][1] (
// Equation(s):
// \Mux14~2  = (\rd_addr~combout [1] & (\rd_addr~combout [0])) # (!\rd_addr~combout [1] & ((\rd_addr~combout [0] & (mem[1][1])) # (!\rd_addr~combout [0] & ((\mem[0][1]~regout )))))

	.clk(\wr_clk~combout ),
	.dataa(\rd_addr~combout [1]),
	.datab(\rd_addr~combout [0]),
	.datac(\data_in~combout [1]),
	.datad(\mem[0][1]~regout ),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~5_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(\Mux14~2 ),
	.regout(\mem[1][1]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[1][1] .lut_mask = "d9c8";
defparam \mem[1][1] .operation_mode = "normal";
defparam \mem[1][1] .output_mode = "comb_only";
defparam \mem[1][1] .register_cascade_mode = "off";
defparam \mem[1][1] .sum_lutc_input = "qfbk";
defparam \mem[1][1] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X5_Y3_N8
maxv_lcell \mem[2][1] (
// Equation(s):
// \Mux14~3  = (\rd_addr~combout [1] & ((\Mux14~2  & (\mem[3][1]~regout )) # (!\Mux14~2  & ((mem[2][1]))))) # (!\rd_addr~combout [1] & (((\Mux14~2 ))))

	.clk(\wr_clk~combout ),
	.dataa(\rd_addr~combout [1]),
	.datab(\mem[3][1]~regout ),
	.datac(\data_in~combout [1]),
	.datad(\Mux14~2 ),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~4_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(\Mux14~3 ),
	.regout(\mem[2][1]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[2][1] .lut_mask = "dda0";
defparam \mem[2][1] .operation_mode = "normal";
defparam \mem[2][1] .output_mode = "comb_only";
defparam \mem[2][1] .register_cascade_mode = "off";
defparam \mem[2][1] .sum_lutc_input = "qfbk";
defparam \mem[2][1] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X5_Y3_N9
maxv_lcell \data_out[1]~reg0 (
// Equation(s):
// \data_out[1]~reg0_regout  = DFFEAS((\rd_addr~combout [2] & (((\Mux14~1 )))) # (!\rd_addr~combout [2] & (((\Mux14~3 )))), GLOBAL(\rd_clk~combout ), !GLOBAL(\clr~combout ), , \re~combout , , , , )

	.clk(\rd_clk~combout ),
	.dataa(\rd_addr~combout [2]),
	.datab(vcc),
	.datac(\Mux14~1 ),
	.datad(\Mux14~3 ),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(\re~combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\data_out[1]~reg0_regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \data_out[1]~reg0 .lut_mask = "f5a0";
defparam \data_out[1]~reg0 .operation_mode = "normal";
defparam \data_out[1]~reg0 .output_mode = "reg_only";
defparam \data_out[1]~reg0 .register_cascade_mode = "off";
defparam \data_out[1]~reg0 .sum_lutc_input = "datac";
defparam \data_out[1]~reg0 .synch_mode = "off";
// synopsys translate_on

// Location: PIN_E10,	 I/O Standard: 3.3-V LVTTL,	 Current Strength: Default
maxv_io \data_in[2]~I (
	.datain(gnd),
	.oe(gnd),
	.combout(\data_in~combout [2]),
	.padio(data_in[2]));
// synopsys translate_off
defparam \data_in[2]~I .operation_mode = "input";
// synopsys translate_on

// Location: LC_X3_Y3_N1
maxv_lcell \mem[7][2] (
// Equation(s):
// \mem[7][2]~regout  = DFFEAS(GND, GLOBAL(\wr_clk~combout ), !GLOBAL(\clr~combout ), , \Decoder0~3_combout , \data_in~combout [2], , , VCC)

	.clk(\wr_clk~combout ),
	.dataa(vcc),
	.datab(vcc),
	.datac(\data_in~combout [2]),
	.datad(vcc),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~3_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\mem[7][2]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[7][2] .lut_mask = "0000";
defparam \mem[7][2] .operation_mode = "normal";
defparam \mem[7][2] .output_mode = "reg_only";
defparam \mem[7][2] .register_cascade_mode = "off";
defparam \mem[7][2] .sum_lutc_input = "datac";
defparam \mem[7][2] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X3_Y3_N4
maxv_lcell \mem[4][2] (
// Equation(s):
// \mem[4][2]~regout  = DFFEAS(GND, GLOBAL(\wr_clk~combout ), !GLOBAL(\clr~combout ), , \Decoder0~2_combout , \data_in~combout [2], , , VCC)

	.clk(\wr_clk~combout ),
	.dataa(vcc),
	.datab(vcc),
	.datac(\data_in~combout [2]),
	.datad(vcc),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~2_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\mem[4][2]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[4][2] .lut_mask = "0000";
defparam \mem[4][2] .operation_mode = "normal";
defparam \mem[4][2] .output_mode = "reg_only";
defparam \mem[4][2] .register_cascade_mode = "off";
defparam \mem[4][2] .sum_lutc_input = "datac";
defparam \mem[4][2] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X4_Y3_N7
maxv_lcell \mem[6][2] (
// Equation(s):
// \Mux13~0  = (\rd_addr~combout [1] & ((\rd_addr~combout [0]) # ((mem[6][2])))) # (!\rd_addr~combout [1] & (!\rd_addr~combout [0] & ((\mem[4][2]~regout ))))

	.clk(\wr_clk~combout ),
	.dataa(\rd_addr~combout [1]),
	.datab(\rd_addr~combout [0]),
	.datac(\data_in~combout [2]),
	.datad(\mem[4][2]~regout ),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~1_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(\Mux13~0 ),
	.regout(\mem[6][2]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[6][2] .lut_mask = "b9a8";
defparam \mem[6][2] .operation_mode = "normal";
defparam \mem[6][2] .output_mode = "comb_only";
defparam \mem[6][2] .register_cascade_mode = "off";
defparam \mem[6][2] .sum_lutc_input = "qfbk";
defparam \mem[6][2] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X4_Y3_N8
maxv_lcell \mem[5][2] (
// Equation(s):
// \Mux13~1  = (\rd_addr~combout [0] & ((\Mux13~0  & (\mem[7][2]~regout )) # (!\Mux13~0  & ((mem[5][2]))))) # (!\rd_addr~combout [0] & (((\Mux13~0 ))))

	.clk(\wr_clk~combout ),
	.dataa(\mem[7][2]~regout ),
	.datab(\rd_addr~combout [0]),
	.datac(\data_in~combout [2]),
	.datad(\Mux13~0 ),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~0_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(\Mux13~1 ),
	.regout(\mem[5][2]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[5][2] .lut_mask = "bbc0";
defparam \mem[5][2] .operation_mode = "normal";
defparam \mem[5][2] .output_mode = "comb_only";
defparam \mem[5][2] .register_cascade_mode = "off";
defparam \mem[5][2] .sum_lutc_input = "qfbk";
defparam \mem[5][2] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X7_Y3_N8
maxv_lcell \mem[3][2] (
// Equation(s):
// \mem[3][2]~regout  = DFFEAS((((\data_in~combout [2]))), GLOBAL(\wr_clk~combout ), !GLOBAL(\clr~combout ), , \Decoder0~7_combout , , , , )

	.clk(\wr_clk~combout ),
	.dataa(vcc),
	.datab(vcc),
	.datac(vcc),
	.datad(\data_in~combout [2]),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(\Decoder0~7_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\mem[3][2]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[3][2] .lut_mask = "ff00";
defparam \mem[3][2] .operation_mode = "normal";
defparam \mem[3][2] .output_mode = "reg_only";
defparam \mem[3][2] .register_cascade_mode = "off";
defparam \mem[3][2] .sum_lutc_input = "datac";
defparam \mem[3][2] .synch_mode = "off";
// synopsys translate_on

// Location: LC_X6_Y3_N4
maxv_lcell \mem[0][2] (
// Equation(s):
// \mem[0][2]~regout  = DFFEAS(GND, GLOBAL(\wr_clk~combout ), !GLOBAL(\clr~combout ), , \Decoder0~6_combout , \data_in~combout [2], , , VCC)

	.clk(\wr_clk~combout ),
	.dataa(vcc),
	.datab(vcc),
	.datac(\data_in~combout [2]),
	.datad(vcc),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~6_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\mem[0][2]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[0][2] .lut_mask = "0000";
defparam \mem[0][2] .operation_mode = "normal";
defparam \mem[0][2] .output_mode = "reg_only";
defparam \mem[0][2] .register_cascade_mode = "off";
defparam \mem[0][2] .sum_lutc_input = "datac";
defparam \mem[0][2] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X6_Y3_N1
maxv_lcell \mem[1][2] (
// Equation(s):
// \Mux13~2  = (\rd_addr~combout [1] & (\rd_addr~combout [0])) # (!\rd_addr~combout [1] & ((\rd_addr~combout [0] & (mem[1][2])) # (!\rd_addr~combout [0] & ((\mem[0][2]~regout )))))

	.clk(\wr_clk~combout ),
	.dataa(\rd_addr~combout [1]),
	.datab(\rd_addr~combout [0]),
	.datac(\data_in~combout [2]),
	.datad(\mem[0][2]~regout ),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~5_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(\Mux13~2 ),
	.regout(\mem[1][2]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[1][2] .lut_mask = "d9c8";
defparam \mem[1][2] .operation_mode = "normal";
defparam \mem[1][2] .output_mode = "comb_only";
defparam \mem[1][2] .register_cascade_mode = "off";
defparam \mem[1][2] .sum_lutc_input = "qfbk";
defparam \mem[1][2] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X5_Y3_N3
maxv_lcell \mem[2][2] (
// Equation(s):
// \Mux13~3  = (\rd_addr~combout [1] & ((\Mux13~2  & (\mem[3][2]~regout )) # (!\Mux13~2  & ((mem[2][2]))))) # (!\rd_addr~combout [1] & (((\Mux13~2 ))))

	.clk(\wr_clk~combout ),
	.dataa(\rd_addr~combout [1]),
	.datab(\mem[3][2]~regout ),
	.datac(\data_in~combout [2]),
	.datad(\Mux13~2 ),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~4_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(\Mux13~3 ),
	.regout(\mem[2][2]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[2][2] .lut_mask = "dda0";
defparam \mem[2][2] .operation_mode = "normal";
defparam \mem[2][2] .output_mode = "comb_only";
defparam \mem[2][2] .register_cascade_mode = "off";
defparam \mem[2][2] .sum_lutc_input = "qfbk";
defparam \mem[2][2] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X5_Y3_N4
maxv_lcell \data_out[2]~reg0 (
// Equation(s):
// \data_out[2]~reg0_regout  = DFFEAS((\rd_addr~combout [2] & (((\Mux13~1 )))) # (!\rd_addr~combout [2] & (((\Mux13~3 )))), GLOBAL(\rd_clk~combout ), !GLOBAL(\clr~combout ), , \re~combout , , , , )

	.clk(\rd_clk~combout ),
	.dataa(\rd_addr~combout [2]),
	.datab(vcc),
	.datac(\Mux13~1 ),
	.datad(\Mux13~3 ),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(\re~combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\data_out[2]~reg0_regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \data_out[2]~reg0 .lut_mask = "f5a0";
defparam \data_out[2]~reg0 .operation_mode = "normal";
defparam \data_out[2]~reg0 .output_mode = "reg_only";
defparam \data_out[2]~reg0 .register_cascade_mode = "off";
defparam \data_out[2]~reg0 .sum_lutc_input = "datac";
defparam \data_out[2]~reg0 .synch_mode = "off";
// synopsys translate_on

// Location: PIN_G10,	 I/O Standard: 3.3-V LVTTL,	 Current Strength: Default
maxv_io \data_in[3]~I (
	.datain(gnd),
	.oe(gnd),
	.combout(\data_in~combout [3]),
	.padio(data_in[3]));
// synopsys translate_off
defparam \data_in[3]~I .operation_mode = "input";
// synopsys translate_on

// Location: LC_X3_Y3_N3
maxv_lcell \mem[7][3] (
// Equation(s):
// \mem[7][3]~regout  = DFFEAS(GND, GLOBAL(\wr_clk~combout ), !GLOBAL(\clr~combout ), , \Decoder0~3_combout , \data_in~combout [3], , , VCC)

	.clk(\wr_clk~combout ),
	.dataa(vcc),
	.datab(vcc),
	.datac(\data_in~combout [3]),
	.datad(vcc),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~3_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\mem[7][3]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[7][3] .lut_mask = "0000";
defparam \mem[7][3] .operation_mode = "normal";
defparam \mem[7][3] .output_mode = "reg_only";
defparam \mem[7][3] .register_cascade_mode = "off";
defparam \mem[7][3] .sum_lutc_input = "datac";
defparam \mem[7][3] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X3_Y3_N0
maxv_lcell \mem[4][3] (
// Equation(s):
// \mem[4][3]~regout  = DFFEAS(GND, GLOBAL(\wr_clk~combout ), !GLOBAL(\clr~combout ), , \Decoder0~2_combout , \data_in~combout [3], , , VCC)

	.clk(\wr_clk~combout ),
	.dataa(vcc),
	.datab(vcc),
	.datac(\data_in~combout [3]),
	.datad(vcc),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~2_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\mem[4][3]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[4][3] .lut_mask = "0000";
defparam \mem[4][3] .operation_mode = "normal";
defparam \mem[4][3] .output_mode = "reg_only";
defparam \mem[4][3] .register_cascade_mode = "off";
defparam \mem[4][3] .sum_lutc_input = "datac";
defparam \mem[4][3] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X4_Y3_N3
maxv_lcell \mem[6][3] (
// Equation(s):
// \Mux12~0  = (\rd_addr~combout [1] & ((\rd_addr~combout [0]) # ((mem[6][3])))) # (!\rd_addr~combout [1] & (!\rd_addr~combout [0] & ((\mem[4][3]~regout ))))

	.clk(\wr_clk~combout ),
	.dataa(\rd_addr~combout [1]),
	.datab(\rd_addr~combout [0]),
	.datac(\data_in~combout [3]),
	.datad(\mem[4][3]~regout ),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~1_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(\Mux12~0 ),
	.regout(\mem[6][3]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[6][3] .lut_mask = "b9a8";
defparam \mem[6][3] .operation_mode = "normal";
defparam \mem[6][3] .output_mode = "comb_only";
defparam \mem[6][3] .register_cascade_mode = "off";
defparam \mem[6][3] .sum_lutc_input = "qfbk";
defparam \mem[6][3] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X4_Y3_N4
maxv_lcell \mem[5][3] (
// Equation(s):
// \Mux12~1  = (\rd_addr~combout [0] & ((\Mux12~0  & (\mem[7][3]~regout )) # (!\Mux12~0  & ((mem[5][3]))))) # (!\rd_addr~combout [0] & (((\Mux12~0 ))))

	.clk(\wr_clk~combout ),
	.dataa(\rd_addr~combout [0]),
	.datab(\mem[7][3]~regout ),
	.datac(\data_in~combout [3]),
	.datad(\Mux12~0 ),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~0_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(\Mux12~1 ),
	.regout(\mem[5][3]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[5][3] .lut_mask = "dda0";
defparam \mem[5][3] .operation_mode = "normal";
defparam \mem[5][3] .output_mode = "comb_only";
defparam \mem[5][3] .register_cascade_mode = "off";
defparam \mem[5][3] .sum_lutc_input = "qfbk";
defparam \mem[5][3] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X7_Y3_N6
maxv_lcell \mem[3][3] (
// Equation(s):
// \mem[3][3]~regout  = DFFEAS((((\data_in~combout [3]))), GLOBAL(\wr_clk~combout ), !GLOBAL(\clr~combout ), , \Decoder0~7_combout , , , , )

	.clk(\wr_clk~combout ),
	.dataa(vcc),
	.datab(vcc),
	.datac(vcc),
	.datad(\data_in~combout [3]),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(\Decoder0~7_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\mem[3][3]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[3][3] .lut_mask = "ff00";
defparam \mem[3][3] .operation_mode = "normal";
defparam \mem[3][3] .output_mode = "reg_only";
defparam \mem[3][3] .register_cascade_mode = "off";
defparam \mem[3][3] .sum_lutc_input = "datac";
defparam \mem[3][3] .synch_mode = "off";
// synopsys translate_on

// Location: LC_X6_Y2_N1
maxv_lcell \mem[0][3] (
// Equation(s):
// \mem[0][3]~regout  = DFFEAS(GND, GLOBAL(\wr_clk~combout ), !GLOBAL(\clr~combout ), , \Decoder0~6_combout , \data_in~combout [3], , , VCC)

	.clk(\wr_clk~combout ),
	.dataa(vcc),
	.datab(vcc),
	.datac(\data_in~combout [3]),
	.datad(vcc),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~6_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\mem[0][3]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[0][3] .lut_mask = "0000";
defparam \mem[0][3] .operation_mode = "normal";
defparam \mem[0][3] .output_mode = "reg_only";
defparam \mem[0][3] .register_cascade_mode = "off";
defparam \mem[0][3] .sum_lutc_input = "datac";
defparam \mem[0][3] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X6_Y2_N4
maxv_lcell \mem[1][3] (
// Equation(s):
// \Mux12~2  = (\rd_addr~combout [1] & (\rd_addr~combout [0])) # (!\rd_addr~combout [1] & ((\rd_addr~combout [0] & (mem[1][3])) # (!\rd_addr~combout [0] & ((\mem[0][3]~regout )))))

	.clk(\wr_clk~combout ),
	.dataa(\rd_addr~combout [1]),
	.datab(\rd_addr~combout [0]),
	.datac(\data_in~combout [3]),
	.datad(\mem[0][3]~regout ),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~5_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(\Mux12~2 ),
	.regout(\mem[1][3]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[1][3] .lut_mask = "d9c8";
defparam \mem[1][3] .operation_mode = "normal";
defparam \mem[1][3] .output_mode = "comb_only";
defparam \mem[1][3] .register_cascade_mode = "off";
defparam \mem[1][3] .sum_lutc_input = "qfbk";
defparam \mem[1][3] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X5_Y3_N0
maxv_lcell \mem[2][3] (
// Equation(s):
// \Mux12~3  = (\rd_addr~combout [1] & ((\Mux12~2  & (\mem[3][3]~regout )) # (!\Mux12~2  & ((mem[2][3]))))) # (!\rd_addr~combout [1] & (((\Mux12~2 ))))

	.clk(\wr_clk~combout ),
	.dataa(\mem[3][3]~regout ),
	.datab(\rd_addr~combout [1]),
	.datac(\data_in~combout [3]),
	.datad(\Mux12~2 ),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~4_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(\Mux12~3 ),
	.regout(\mem[2][3]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[2][3] .lut_mask = "bbc0";
defparam \mem[2][3] .operation_mode = "normal";
defparam \mem[2][3] .output_mode = "comb_only";
defparam \mem[2][3] .register_cascade_mode = "off";
defparam \mem[2][3] .sum_lutc_input = "qfbk";
defparam \mem[2][3] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X5_Y3_N1
maxv_lcell \data_out[3]~reg0 (
// Equation(s):
// \data_out[3]~reg0_regout  = DFFEAS((\rd_addr~combout [2] & (\Mux12~1 )) # (!\rd_addr~combout [2] & (((\Mux12~3 )))), GLOBAL(\rd_clk~combout ), !GLOBAL(\clr~combout ), , \re~combout , , , , )

	.clk(\rd_clk~combout ),
	.dataa(\rd_addr~combout [2]),
	.datab(\Mux12~1 ),
	.datac(vcc),
	.datad(\Mux12~3 ),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(\re~combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\data_out[3]~reg0_regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \data_out[3]~reg0 .lut_mask = "dd88";
defparam \data_out[3]~reg0 .operation_mode = "normal";
defparam \data_out[3]~reg0 .output_mode = "reg_only";
defparam \data_out[3]~reg0 .register_cascade_mode = "off";
defparam \data_out[3]~reg0 .sum_lutc_input = "datac";
defparam \data_out[3]~reg0 .synch_mode = "off";
// synopsys translate_on

// Location: PIN_K5,	 I/O Standard: 3.3-V LVTTL,	 Current Strength: Default
maxv_io \data_in[4]~I (
	.datain(gnd),
	.oe(gnd),
	.combout(\data_in~combout [4]),
	.padio(data_in[4]));
// synopsys translate_off
defparam \data_in[4]~I .operation_mode = "input";
// synopsys translate_on

// Location: LC_X4_Y4_N5
maxv_lcell \mem[3][4] (
// Equation(s):
// \mem[3][4]~regout  = DFFEAS((((\data_in~combout [4]))), GLOBAL(\wr_clk~combout ), !GLOBAL(\clr~combout ), , \Decoder0~7_combout , , , , )

	.clk(\wr_clk~combout ),
	.dataa(vcc),
	.datab(vcc),
	.datac(vcc),
	.datad(\data_in~combout [4]),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(\Decoder0~7_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\mem[3][4]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[3][4] .lut_mask = "ff00";
defparam \mem[3][4] .operation_mode = "normal";
defparam \mem[3][4] .output_mode = "reg_only";
defparam \mem[3][4] .register_cascade_mode = "off";
defparam \mem[3][4] .sum_lutc_input = "datac";
defparam \mem[3][4] .synch_mode = "off";
// synopsys translate_on

// Location: LC_X6_Y3_N0
maxv_lcell \mem[0][4] (
// Equation(s):
// \mem[0][4]~regout  = DFFEAS(GND, GLOBAL(\wr_clk~combout ), !GLOBAL(\clr~combout ), , \Decoder0~6_combout , \data_in~combout [4], , , VCC)

	.clk(\wr_clk~combout ),
	.dataa(vcc),
	.datab(vcc),
	.datac(\data_in~combout [4]),
	.datad(vcc),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~6_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\mem[0][4]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[0][4] .lut_mask = "0000";
defparam \mem[0][4] .operation_mode = "normal";
defparam \mem[0][4] .output_mode = "reg_only";
defparam \mem[0][4] .register_cascade_mode = "off";
defparam \mem[0][4] .sum_lutc_input = "datac";
defparam \mem[0][4] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X6_Y3_N5
maxv_lcell \mem[1][4] (
// Equation(s):
// \Mux11~2  = (\rd_addr~combout [1] & (\rd_addr~combout [0])) # (!\rd_addr~combout [1] & ((\rd_addr~combout [0] & (mem[1][4])) # (!\rd_addr~combout [0] & ((\mem[0][4]~regout )))))

	.clk(\wr_clk~combout ),
	.dataa(\rd_addr~combout [1]),
	.datab(\rd_addr~combout [0]),
	.datac(\data_in~combout [4]),
	.datad(\mem[0][4]~regout ),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~5_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(\Mux11~2 ),
	.regout(\mem[1][4]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[1][4] .lut_mask = "d9c8";
defparam \mem[1][4] .operation_mode = "normal";
defparam \mem[1][4] .output_mode = "comb_only";
defparam \mem[1][4] .register_cascade_mode = "off";
defparam \mem[1][4] .sum_lutc_input = "qfbk";
defparam \mem[1][4] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X5_Y3_N5
maxv_lcell \mem[2][4] (
// Equation(s):
// \Mux11~3  = (\rd_addr~combout [1] & ((\Mux11~2  & (\mem[3][4]~regout )) # (!\Mux11~2  & ((mem[2][4]))))) # (!\rd_addr~combout [1] & (((\Mux11~2 ))))

	.clk(\wr_clk~combout ),
	.dataa(\rd_addr~combout [1]),
	.datab(\mem[3][4]~regout ),
	.datac(\data_in~combout [4]),
	.datad(\Mux11~2 ),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~4_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(\Mux11~3 ),
	.regout(\mem[2][4]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[2][4] .lut_mask = "dda0";
defparam \mem[2][4] .operation_mode = "normal";
defparam \mem[2][4] .output_mode = "comb_only";
defparam \mem[2][4] .register_cascade_mode = "off";
defparam \mem[2][4] .sum_lutc_input = "qfbk";
defparam \mem[2][4] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X4_Y4_N1
maxv_lcell \mem[7][4] (
// Equation(s):
// \mem[7][4]~regout  = DFFEAS((((\data_in~combout [4]))), GLOBAL(\wr_clk~combout ), !GLOBAL(\clr~combout ), , \Decoder0~3_combout , , , , )

	.clk(\wr_clk~combout ),
	.dataa(vcc),
	.datab(vcc),
	.datac(vcc),
	.datad(\data_in~combout [4]),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(\Decoder0~3_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\mem[7][4]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[7][4] .lut_mask = "ff00";
defparam \mem[7][4] .operation_mode = "normal";
defparam \mem[7][4] .output_mode = "reg_only";
defparam \mem[7][4] .register_cascade_mode = "off";
defparam \mem[7][4] .sum_lutc_input = "datac";
defparam \mem[7][4] .synch_mode = "off";
// synopsys translate_on

// Location: LC_X3_Y1_N0
maxv_lcell \mem[4][4] (
// Equation(s):
// \mem[4][4]~regout  = DFFEAS((((\data_in~combout [4]))), GLOBAL(\wr_clk~combout ), !GLOBAL(\clr~combout ), , \Decoder0~2_combout , , , , )

	.clk(\wr_clk~combout ),
	.dataa(vcc),
	.datab(vcc),
	.datac(vcc),
	.datad(\data_in~combout [4]),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(\Decoder0~2_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\mem[4][4]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[4][4] .lut_mask = "ff00";
defparam \mem[4][4] .operation_mode = "normal";
defparam \mem[4][4] .output_mode = "reg_only";
defparam \mem[4][4] .register_cascade_mode = "off";
defparam \mem[4][4] .sum_lutc_input = "datac";
defparam \mem[4][4] .synch_mode = "off";
// synopsys translate_on

// Location: LC_X4_Y1_N3
maxv_lcell \mem[6][4] (
// Equation(s):
// \Mux11~0  = (\rd_addr~combout [0] & (\rd_addr~combout [1])) # (!\rd_addr~combout [0] & ((\rd_addr~combout [1] & (mem[6][4])) # (!\rd_addr~combout [1] & ((\mem[4][4]~regout )))))

	.clk(\wr_clk~combout ),
	.dataa(\rd_addr~combout [0]),
	.datab(\rd_addr~combout [1]),
	.datac(\data_in~combout [4]),
	.datad(\mem[4][4]~regout ),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~1_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(\Mux11~0 ),
	.regout(\mem[6][4]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[6][4] .lut_mask = "d9c8";
defparam \mem[6][4] .operation_mode = "normal";
defparam \mem[6][4] .output_mode = "comb_only";
defparam \mem[6][4] .register_cascade_mode = "off";
defparam \mem[6][4] .sum_lutc_input = "qfbk";
defparam \mem[6][4] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X4_Y1_N2
maxv_lcell \mem[5][4] (
// Equation(s):
// \Mux11~1  = (\rd_addr~combout [0] & ((\Mux11~0  & (\mem[7][4]~regout )) # (!\Mux11~0  & ((mem[5][4]))))) # (!\rd_addr~combout [0] & (((\Mux11~0 ))))

	.clk(\wr_clk~combout ),
	.dataa(\rd_addr~combout [0]),
	.datab(\mem[7][4]~regout ),
	.datac(\data_in~combout [4]),
	.datad(\Mux11~0 ),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~0_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(\Mux11~1 ),
	.regout(\mem[5][4]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[5][4] .lut_mask = "dda0";
defparam \mem[5][4] .operation_mode = "normal";
defparam \mem[5][4] .output_mode = "comb_only";
defparam \mem[5][4] .register_cascade_mode = "off";
defparam \mem[5][4] .sum_lutc_input = "qfbk";
defparam \mem[5][4] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X5_Y3_N2
maxv_lcell \data_out[4]~reg0 (
// Equation(s):
// \data_out[4]~reg0_regout  = DFFEAS((\rd_addr~combout [2] & (((\Mux11~1 )))) # (!\rd_addr~combout [2] & (((\Mux11~3 )))), GLOBAL(\rd_clk~combout ), !GLOBAL(\clr~combout ), , \re~combout , , , , )

	.clk(\rd_clk~combout ),
	.dataa(\rd_addr~combout [2]),
	.datab(vcc),
	.datac(\Mux11~3 ),
	.datad(\Mux11~1 ),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(\re~combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\data_out[4]~reg0_regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \data_out[4]~reg0 .lut_mask = "fa50";
defparam \data_out[4]~reg0 .operation_mode = "normal";
defparam \data_out[4]~reg0 .output_mode = "reg_only";
defparam \data_out[4]~reg0 .register_cascade_mode = "off";
defparam \data_out[4]~reg0 .sum_lutc_input = "datac";
defparam \data_out[4]~reg0 .synch_mode = "off";
// synopsys translate_on

// Location: PIN_L4,	 I/O Standard: 3.3-V LVTTL,	 Current Strength: Default
maxv_io \data_in[5]~I (
	.datain(gnd),
	.oe(gnd),
	.combout(\data_in~combout [5]),
	.padio(data_in[5]));
// synopsys translate_off
defparam \data_in[5]~I .operation_mode = "input";
// synopsys translate_on

// Location: LC_X4_Y4_N8
maxv_lcell \mem[7][5] (
// Equation(s):
// \mem[7][5]~regout  = DFFEAS(GND, GLOBAL(\wr_clk~combout ), !GLOBAL(\clr~combout ), , \Decoder0~3_combout , \data_in~combout [5], , , VCC)

	.clk(\wr_clk~combout ),
	.dataa(vcc),
	.datab(vcc),
	.datac(\data_in~combout [5]),
	.datad(vcc),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~3_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\mem[7][5]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[7][5] .lut_mask = "0000";
defparam \mem[7][5] .operation_mode = "normal";
defparam \mem[7][5] .output_mode = "reg_only";
defparam \mem[7][5] .register_cascade_mode = "off";
defparam \mem[7][5] .sum_lutc_input = "datac";
defparam \mem[7][5] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X3_Y1_N5
maxv_lcell \mem[4][5] (
// Equation(s):
// \mem[4][5]~regout  = DFFEAS(GND, GLOBAL(\wr_clk~combout ), !GLOBAL(\clr~combout ), , \Decoder0~2_combout , \data_in~combout [5], , , VCC)

	.clk(\wr_clk~combout ),
	.dataa(vcc),
	.datab(vcc),
	.datac(\data_in~combout [5]),
	.datad(vcc),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~2_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\mem[4][5]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[4][5] .lut_mask = "0000";
defparam \mem[4][5] .operation_mode = "normal";
defparam \mem[4][5] .output_mode = "reg_only";
defparam \mem[4][5] .register_cascade_mode = "off";
defparam \mem[4][5] .sum_lutc_input = "datac";
defparam \mem[4][5] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X4_Y1_N0
maxv_lcell \mem[6][5] (
// Equation(s):
// \Mux10~0  = (\rd_addr~combout [1] & ((\rd_addr~combout [0]) # ((mem[6][5])))) # (!\rd_addr~combout [1] & (!\rd_addr~combout [0] & ((\mem[4][5]~regout ))))

	.clk(\wr_clk~combout ),
	.dataa(\rd_addr~combout [1]),
	.datab(\rd_addr~combout [0]),
	.datac(\data_in~combout [5]),
	.datad(\mem[4][5]~regout ),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~1_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(\Mux10~0 ),
	.regout(\mem[6][5]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[6][5] .lut_mask = "b9a8";
defparam \mem[6][5] .operation_mode = "normal";
defparam \mem[6][5] .output_mode = "comb_only";
defparam \mem[6][5] .register_cascade_mode = "off";
defparam \mem[6][5] .sum_lutc_input = "qfbk";
defparam \mem[6][5] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X4_Y1_N1
maxv_lcell \mem[5][5] (
// Equation(s):
// \Mux10~1  = (\rd_addr~combout [0] & ((\Mux10~0  & (\mem[7][5]~regout )) # (!\Mux10~0  & ((mem[5][5]))))) # (!\rd_addr~combout [0] & (((\Mux10~0 ))))

	.clk(\wr_clk~combout ),
	.dataa(\rd_addr~combout [0]),
	.datab(\mem[7][5]~regout ),
	.datac(\data_in~combout [5]),
	.datad(\Mux10~0 ),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~0_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(\Mux10~1 ),
	.regout(\mem[5][5]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[5][5] .lut_mask = "dda0";
defparam \mem[5][5] .operation_mode = "normal";
defparam \mem[5][5] .output_mode = "comb_only";
defparam \mem[5][5] .register_cascade_mode = "off";
defparam \mem[5][5] .sum_lutc_input = "qfbk";
defparam \mem[5][5] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X6_Y4_N9
maxv_lcell \mem[3][5] (
// Equation(s):
// \mem[3][5]~regout  = DFFEAS((((\data_in~combout [5]))), GLOBAL(\wr_clk~combout ), !GLOBAL(\clr~combout ), , \Decoder0~7_combout , , , , )

	.clk(\wr_clk~combout ),
	.dataa(vcc),
	.datab(vcc),
	.datac(vcc),
	.datad(\data_in~combout [5]),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(\Decoder0~7_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\mem[3][5]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[3][5] .lut_mask = "ff00";
defparam \mem[3][5] .operation_mode = "normal";
defparam \mem[3][5] .output_mode = "reg_only";
defparam \mem[3][5] .register_cascade_mode = "off";
defparam \mem[3][5] .sum_lutc_input = "datac";
defparam \mem[3][5] .synch_mode = "off";
// synopsys translate_on

// Location: LC_X6_Y2_N3
maxv_lcell \mem[0][5] (
// Equation(s):
// \mem[0][5]~regout  = DFFEAS(GND, GLOBAL(\wr_clk~combout ), !GLOBAL(\clr~combout ), , \Decoder0~6_combout , \data_in~combout [5], , , VCC)

	.clk(\wr_clk~combout ),
	.dataa(vcc),
	.datab(vcc),
	.datac(\data_in~combout [5]),
	.datad(vcc),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~6_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\mem[0][5]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[0][5] .lut_mask = "0000";
defparam \mem[0][5] .operation_mode = "normal";
defparam \mem[0][5] .output_mode = "reg_only";
defparam \mem[0][5] .register_cascade_mode = "off";
defparam \mem[0][5] .sum_lutc_input = "datac";
defparam \mem[0][5] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X6_Y2_N2
maxv_lcell \mem[1][5] (
// Equation(s):
// \Mux10~2  = (\rd_addr~combout [1] & (\rd_addr~combout [0])) # (!\rd_addr~combout [1] & ((\rd_addr~combout [0] & (mem[1][5])) # (!\rd_addr~combout [0] & ((\mem[0][5]~regout )))))

	.clk(\wr_clk~combout ),
	.dataa(\rd_addr~combout [1]),
	.datab(\rd_addr~combout [0]),
	.datac(\data_in~combout [5]),
	.datad(\mem[0][5]~regout ),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~5_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(\Mux10~2 ),
	.regout(\mem[1][5]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[1][5] .lut_mask = "d9c8";
defparam \mem[1][5] .operation_mode = "normal";
defparam \mem[1][5] .output_mode = "comb_only";
defparam \mem[1][5] .register_cascade_mode = "off";
defparam \mem[1][5] .sum_lutc_input = "qfbk";
defparam \mem[1][5] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X5_Y1_N8
maxv_lcell \mem[2][5] (
// Equation(s):
// \Mux10~3  = (\rd_addr~combout [1] & ((\Mux10~2  & (\mem[3][5]~regout )) # (!\Mux10~2  & ((mem[2][5]))))) # (!\rd_addr~combout [1] & (((\Mux10~2 ))))

	.clk(\wr_clk~combout ),
	.dataa(\rd_addr~combout [1]),
	.datab(\mem[3][5]~regout ),
	.datac(\data_in~combout [5]),
	.datad(\Mux10~2 ),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~4_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(\Mux10~3 ),
	.regout(\mem[2][5]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[2][5] .lut_mask = "dda0";
defparam \mem[2][5] .operation_mode = "normal";
defparam \mem[2][5] .output_mode = "comb_only";
defparam \mem[2][5] .register_cascade_mode = "off";
defparam \mem[2][5] .sum_lutc_input = "qfbk";
defparam \mem[2][5] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X5_Y1_N9
maxv_lcell \data_out[5]~reg0 (
// Equation(s):
// \data_out[5]~reg0_regout  = DFFEAS(((\rd_addr~combout [2] & (\Mux10~1 )) # (!\rd_addr~combout [2] & ((\Mux10~3 )))), GLOBAL(\rd_clk~combout ), !GLOBAL(\clr~combout ), , \re~combout , , , , )

	.clk(\rd_clk~combout ),
	.dataa(vcc),
	.datab(\rd_addr~combout [2]),
	.datac(\Mux10~1 ),
	.datad(\Mux10~3 ),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(\re~combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\data_out[5]~reg0_regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \data_out[5]~reg0 .lut_mask = "f3c0";
defparam \data_out[5]~reg0 .operation_mode = "normal";
defparam \data_out[5]~reg0 .output_mode = "reg_only";
defparam \data_out[5]~reg0 .register_cascade_mode = "off";
defparam \data_out[5]~reg0 .sum_lutc_input = "datac";
defparam \data_out[5]~reg0 .synch_mode = "off";
// synopsys translate_on

// Location: PIN_L5,	 I/O Standard: 3.3-V LVTTL,	 Current Strength: Default
maxv_io \data_in[6]~I (
	.datain(gnd),
	.oe(gnd),
	.combout(\data_in~combout [6]),
	.padio(data_in[6]));
// synopsys translate_off
defparam \data_in[6]~I .operation_mode = "input";
// synopsys translate_on

// Location: LC_X3_Y1_N1
maxv_lcell \mem[7][6] (
// Equation(s):
// \mem[7][6]~regout  = DFFEAS(GND, GLOBAL(\wr_clk~combout ), !GLOBAL(\clr~combout ), , \Decoder0~3_combout , \data_in~combout [6], , , VCC)

	.clk(\wr_clk~combout ),
	.dataa(vcc),
	.datab(vcc),
	.datac(\data_in~combout [6]),
	.datad(vcc),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~3_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\mem[7][6]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[7][6] .lut_mask = "0000";
defparam \mem[7][6] .operation_mode = "normal";
defparam \mem[7][6] .output_mode = "reg_only";
defparam \mem[7][6] .register_cascade_mode = "off";
defparam \mem[7][6] .sum_lutc_input = "datac";
defparam \mem[7][6] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X3_Y1_N3
maxv_lcell \mem[4][6] (
// Equation(s):
// \mem[4][6]~regout  = DFFEAS(GND, GLOBAL(\wr_clk~combout ), !GLOBAL(\clr~combout ), , \Decoder0~2_combout , \data_in~combout [6], , , VCC)

	.clk(\wr_clk~combout ),
	.dataa(vcc),
	.datab(vcc),
	.datac(\data_in~combout [6]),
	.datad(vcc),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~2_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\mem[4][6]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[4][6] .lut_mask = "0000";
defparam \mem[4][6] .operation_mode = "normal";
defparam \mem[4][6] .output_mode = "reg_only";
defparam \mem[4][6] .register_cascade_mode = "off";
defparam \mem[4][6] .sum_lutc_input = "datac";
defparam \mem[4][6] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X4_Y1_N9
maxv_lcell \mem[6][6] (
// Equation(s):
// \Mux9~0  = (\rd_addr~combout [1] & ((\rd_addr~combout [0]) # ((mem[6][6])))) # (!\rd_addr~combout [1] & (!\rd_addr~combout [0] & ((\mem[4][6]~regout ))))

	.clk(\wr_clk~combout ),
	.dataa(\rd_addr~combout [1]),
	.datab(\rd_addr~combout [0]),
	.datac(\data_in~combout [6]),
	.datad(\mem[4][6]~regout ),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~1_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(\Mux9~0 ),
	.regout(\mem[6][6]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[6][6] .lut_mask = "b9a8";
defparam \mem[6][6] .operation_mode = "normal";
defparam \mem[6][6] .output_mode = "comb_only";
defparam \mem[6][6] .register_cascade_mode = "off";
defparam \mem[6][6] .sum_lutc_input = "qfbk";
defparam \mem[6][6] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X4_Y1_N6
maxv_lcell \mem[5][6] (
// Equation(s):
// \Mux9~1  = (\rd_addr~combout [0] & ((\Mux9~0  & (\mem[7][6]~regout )) # (!\Mux9~0  & ((mem[5][6]))))) # (!\rd_addr~combout [0] & (((\Mux9~0 ))))

	.clk(\wr_clk~combout ),
	.dataa(\mem[7][6]~regout ),
	.datab(\rd_addr~combout [0]),
	.datac(\data_in~combout [6]),
	.datad(\Mux9~0 ),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~0_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(\Mux9~1 ),
	.regout(\mem[5][6]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[5][6] .lut_mask = "bbc0";
defparam \mem[5][6] .operation_mode = "normal";
defparam \mem[5][6] .output_mode = "comb_only";
defparam \mem[5][6] .register_cascade_mode = "off";
defparam \mem[5][6] .sum_lutc_input = "qfbk";
defparam \mem[5][6] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X4_Y4_N6
maxv_lcell \mem[3][6] (
// Equation(s):
// \mem[3][6]~regout  = DFFEAS((((\data_in~combout [6]))), GLOBAL(\wr_clk~combout ), !GLOBAL(\clr~combout ), , \Decoder0~7_combout , , , , )

	.clk(\wr_clk~combout ),
	.dataa(vcc),
	.datab(vcc),
	.datac(vcc),
	.datad(\data_in~combout [6]),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(\Decoder0~7_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\mem[3][6]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[3][6] .lut_mask = "ff00";
defparam \mem[3][6] .operation_mode = "normal";
defparam \mem[3][6] .output_mode = "reg_only";
defparam \mem[3][6] .register_cascade_mode = "off";
defparam \mem[3][6] .sum_lutc_input = "datac";
defparam \mem[3][6] .synch_mode = "off";
// synopsys translate_on

// Location: LC_X6_Y1_N2
maxv_lcell \mem[0][6] (
// Equation(s):
// \mem[0][6]~regout  = DFFEAS(GND, GLOBAL(\wr_clk~combout ), !GLOBAL(\clr~combout ), , \Decoder0~6_combout , \data_in~combout [6], , , VCC)

	.clk(\wr_clk~combout ),
	.dataa(vcc),
	.datab(vcc),
	.datac(\data_in~combout [6]),
	.datad(vcc),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~6_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\mem[0][6]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[0][6] .lut_mask = "0000";
defparam \mem[0][6] .operation_mode = "normal";
defparam \mem[0][6] .output_mode = "reg_only";
defparam \mem[0][6] .register_cascade_mode = "off";
defparam \mem[0][6] .sum_lutc_input = "datac";
defparam \mem[0][6] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X6_Y1_N4
maxv_lcell \mem[1][6] (
// Equation(s):
// \Mux9~2  = (\rd_addr~combout [1] & (\rd_addr~combout [0])) # (!\rd_addr~combout [1] & ((\rd_addr~combout [0] & (mem[1][6])) # (!\rd_addr~combout [0] & ((\mem[0][6]~regout )))))

	.clk(\wr_clk~combout ),
	.dataa(\rd_addr~combout [1]),
	.datab(\rd_addr~combout [0]),
	.datac(\data_in~combout [6]),
	.datad(\mem[0][6]~regout ),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~5_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(\Mux9~2 ),
	.regout(\mem[1][6]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[1][6] .lut_mask = "d9c8";
defparam \mem[1][6] .operation_mode = "normal";
defparam \mem[1][6] .output_mode = "comb_only";
defparam \mem[1][6] .register_cascade_mode = "off";
defparam \mem[1][6] .sum_lutc_input = "qfbk";
defparam \mem[1][6] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X5_Y1_N6
maxv_lcell \mem[2][6] (
// Equation(s):
// \Mux9~3  = (\rd_addr~combout [1] & ((\Mux9~2  & (\mem[3][6]~regout )) # (!\Mux9~2  & ((mem[2][6]))))) # (!\rd_addr~combout [1] & (((\Mux9~2 ))))

	.clk(\wr_clk~combout ),
	.dataa(\rd_addr~combout [1]),
	.datab(\mem[3][6]~regout ),
	.datac(\data_in~combout [6]),
	.datad(\Mux9~2 ),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~4_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(\Mux9~3 ),
	.regout(\mem[2][6]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[2][6] .lut_mask = "dda0";
defparam \mem[2][6] .operation_mode = "normal";
defparam \mem[2][6] .output_mode = "comb_only";
defparam \mem[2][6] .register_cascade_mode = "off";
defparam \mem[2][6] .sum_lutc_input = "qfbk";
defparam \mem[2][6] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X5_Y1_N7
maxv_lcell \data_out[6]~reg0 (
// Equation(s):
// \data_out[6]~reg0_regout  = DFFEAS(((\rd_addr~combout [2] & (\Mux9~1 )) # (!\rd_addr~combout [2] & ((\Mux9~3 )))), GLOBAL(\rd_clk~combout ), !GLOBAL(\clr~combout ), , \re~combout , , , , )

	.clk(\rd_clk~combout ),
	.dataa(vcc),
	.datab(\rd_addr~combout [2]),
	.datac(\Mux9~1 ),
	.datad(\Mux9~3 ),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(\re~combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\data_out[6]~reg0_regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \data_out[6]~reg0 .lut_mask = "f3c0";
defparam \data_out[6]~reg0 .operation_mode = "normal";
defparam \data_out[6]~reg0 .output_mode = "reg_only";
defparam \data_out[6]~reg0 .register_cascade_mode = "off";
defparam \data_out[6]~reg0 .sum_lutc_input = "datac";
defparam \data_out[6]~reg0 .synch_mode = "off";
// synopsys translate_on

// Location: PIN_B5,	 I/O Standard: 3.3-V LVTTL,	 Current Strength: Default
maxv_io \data_in[7]~I (
	.datain(gnd),
	.oe(gnd),
	.combout(\data_in~combout [7]),
	.padio(data_in[7]));
// synopsys translate_off
defparam \data_in[7]~I .operation_mode = "input";
// synopsys translate_on

// Location: LC_X3_Y1_N9
maxv_lcell \mem[7][7] (
// Equation(s):
// \mem[7][7]~regout  = DFFEAS((((\data_in~combout [7]))), GLOBAL(\wr_clk~combout ), !GLOBAL(\clr~combout ), , \Decoder0~3_combout , , , , )

	.clk(\wr_clk~combout ),
	.dataa(vcc),
	.datab(vcc),
	.datac(vcc),
	.datad(\data_in~combout [7]),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(\Decoder0~3_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\mem[7][7]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[7][7] .lut_mask = "ff00";
defparam \mem[7][7] .operation_mode = "normal";
defparam \mem[7][7] .output_mode = "reg_only";
defparam \mem[7][7] .register_cascade_mode = "off";
defparam \mem[7][7] .sum_lutc_input = "datac";
defparam \mem[7][7] .synch_mode = "off";
// synopsys translate_on

// Location: LC_X3_Y1_N2
maxv_lcell \mem[4][7] (
// Equation(s):
// \mem[4][7]~regout  = DFFEAS((((\data_in~combout [7]))), GLOBAL(\wr_clk~combout ), !GLOBAL(\clr~combout ), , \Decoder0~2_combout , , , , )

	.clk(\wr_clk~combout ),
	.dataa(vcc),
	.datab(vcc),
	.datac(vcc),
	.datad(\data_in~combout [7]),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(\Decoder0~2_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\mem[4][7]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[4][7] .lut_mask = "ff00";
defparam \mem[4][7] .operation_mode = "normal";
defparam \mem[4][7] .output_mode = "reg_only";
defparam \mem[4][7] .register_cascade_mode = "off";
defparam \mem[4][7] .sum_lutc_input = "datac";
defparam \mem[4][7] .synch_mode = "off";
// synopsys translate_on

// Location: LC_X4_Y1_N8
maxv_lcell \mem[6][7] (
// Equation(s):
// \Mux8~0  = (\rd_addr~combout [1] & ((\rd_addr~combout [0]) # ((mem[6][7])))) # (!\rd_addr~combout [1] & (!\rd_addr~combout [0] & ((\mem[4][7]~regout ))))

	.clk(\wr_clk~combout ),
	.dataa(\rd_addr~combout [1]),
	.datab(\rd_addr~combout [0]),
	.datac(\data_in~combout [7]),
	.datad(\mem[4][7]~regout ),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~1_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(\Mux8~0 ),
	.regout(\mem[6][7]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[6][7] .lut_mask = "b9a8";
defparam \mem[6][7] .operation_mode = "normal";
defparam \mem[6][7] .output_mode = "comb_only";
defparam \mem[6][7] .register_cascade_mode = "off";
defparam \mem[6][7] .sum_lutc_input = "qfbk";
defparam \mem[6][7] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X4_Y1_N7
maxv_lcell \mem[5][7] (
// Equation(s):
// \Mux8~1  = (\rd_addr~combout [0] & ((\Mux8~0  & (\mem[7][7]~regout )) # (!\Mux8~0  & ((mem[5][7]))))) # (!\rd_addr~combout [0] & (((\Mux8~0 ))))

	.clk(\wr_clk~combout ),
	.dataa(\rd_addr~combout [0]),
	.datab(\mem[7][7]~regout ),
	.datac(\data_in~combout [7]),
	.datad(\Mux8~0 ),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~0_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(\Mux8~1 ),
	.regout(\mem[5][7]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[5][7] .lut_mask = "dda0";
defparam \mem[5][7] .operation_mode = "normal";
defparam \mem[5][7] .output_mode = "comb_only";
defparam \mem[5][7] .register_cascade_mode = "off";
defparam \mem[5][7] .sum_lutc_input = "qfbk";
defparam \mem[5][7] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X4_Y4_N2
maxv_lcell \mem[3][7] (
// Equation(s):
// \mem[3][7]~regout  = DFFEAS((((\data_in~combout [7]))), GLOBAL(\wr_clk~combout ), !GLOBAL(\clr~combout ), , \Decoder0~7_combout , , , , )

	.clk(\wr_clk~combout ),
	.dataa(vcc),
	.datab(vcc),
	.datac(vcc),
	.datad(\data_in~combout [7]),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(\Decoder0~7_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\mem[3][7]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[3][7] .lut_mask = "ff00";
defparam \mem[3][7] .operation_mode = "normal";
defparam \mem[3][7] .output_mode = "reg_only";
defparam \mem[3][7] .register_cascade_mode = "off";
defparam \mem[3][7] .sum_lutc_input = "datac";
defparam \mem[3][7] .synch_mode = "off";
// synopsys translate_on

// Location: LC_X6_Y3_N3
maxv_lcell \mem[0][7] (
// Equation(s):
// \mem[0][7]~regout  = DFFEAS(GND, GLOBAL(\wr_clk~combout ), !GLOBAL(\clr~combout ), , \Decoder0~6_combout , \data_in~combout [7], , , VCC)

	.clk(\wr_clk~combout ),
	.dataa(vcc),
	.datab(vcc),
	.datac(\data_in~combout [7]),
	.datad(vcc),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~6_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\mem[0][7]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[0][7] .lut_mask = "0000";
defparam \mem[0][7] .operation_mode = "normal";
defparam \mem[0][7] .output_mode = "reg_only";
defparam \mem[0][7] .register_cascade_mode = "off";
defparam \mem[0][7] .sum_lutc_input = "datac";
defparam \mem[0][7] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X6_Y3_N6
maxv_lcell \mem[1][7] (
// Equation(s):
// \Mux8~2  = (\rd_addr~combout [1] & (\rd_addr~combout [0])) # (!\rd_addr~combout [1] & ((\rd_addr~combout [0] & (mem[1][7])) # (!\rd_addr~combout [0] & ((\mem[0][7]~regout )))))

	.clk(\wr_clk~combout ),
	.dataa(\rd_addr~combout [1]),
	.datab(\rd_addr~combout [0]),
	.datac(\data_in~combout [7]),
	.datad(\mem[0][7]~regout ),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~5_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(\Mux8~2 ),
	.regout(\mem[1][7]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[1][7] .lut_mask = "d9c8";
defparam \mem[1][7] .operation_mode = "normal";
defparam \mem[1][7] .output_mode = "comb_only";
defparam \mem[1][7] .register_cascade_mode = "off";
defparam \mem[1][7] .sum_lutc_input = "qfbk";
defparam \mem[1][7] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X5_Y1_N1
maxv_lcell \mem[2][7] (
// Equation(s):
// \Mux8~3  = (\rd_addr~combout [1] & ((\Mux8~2  & (\mem[3][7]~regout )) # (!\Mux8~2  & ((mem[2][7]))))) # (!\rd_addr~combout [1] & (((\Mux8~2 ))))

	.clk(\wr_clk~combout ),
	.dataa(\mem[3][7]~regout ),
	.datab(\rd_addr~combout [1]),
	.datac(\data_in~combout [7]),
	.datad(\Mux8~2 ),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~4_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(\Mux8~3 ),
	.regout(\mem[2][7]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[2][7] .lut_mask = "bbc0";
defparam \mem[2][7] .operation_mode = "normal";
defparam \mem[2][7] .output_mode = "comb_only";
defparam \mem[2][7] .register_cascade_mode = "off";
defparam \mem[2][7] .sum_lutc_input = "qfbk";
defparam \mem[2][7] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X5_Y1_N2
maxv_lcell \data_out[7]~reg0 (
// Equation(s):
// \data_out[7]~reg0_regout  = DFFEAS(((\rd_addr~combout [2] & (\Mux8~1 )) # (!\rd_addr~combout [2] & ((\Mux8~3 )))), GLOBAL(\rd_clk~combout ), !GLOBAL(\clr~combout ), , \re~combout , , , , )

	.clk(\rd_clk~combout ),
	.dataa(vcc),
	.datab(\Mux8~1 ),
	.datac(\rd_addr~combout [2]),
	.datad(\Mux8~3 ),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(\re~combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\data_out[7]~reg0_regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \data_out[7]~reg0 .lut_mask = "cfc0";
defparam \data_out[7]~reg0 .operation_mode = "normal";
defparam \data_out[7]~reg0 .output_mode = "reg_only";
defparam \data_out[7]~reg0 .register_cascade_mode = "off";
defparam \data_out[7]~reg0 .sum_lutc_input = "datac";
defparam \data_out[7]~reg0 .synch_mode = "off";
// synopsys translate_on

// Location: PIN_A4,	 I/O Standard: 3.3-V LVTTL,	 Current Strength: Default
maxv_io \data_in[8]~I (
	.datain(gnd),
	.oe(gnd),
	.combout(\data_in~combout [8]),
	.padio(data_in[8]));
// synopsys translate_off
defparam \data_in[8]~I .operation_mode = "input";
// synopsys translate_on

// Location: LC_X6_Y4_N3
maxv_lcell \mem[3][8] (
// Equation(s):
// \mem[3][8]~regout  = DFFEAS(GND, GLOBAL(\wr_clk~combout ), !GLOBAL(\clr~combout ), , \Decoder0~7_combout , \data_in~combout [8], , , VCC)

	.clk(\wr_clk~combout ),
	.dataa(vcc),
	.datab(vcc),
	.datac(\data_in~combout [8]),
	.datad(vcc),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~7_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\mem[3][8]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[3][8] .lut_mask = "0000";
defparam \mem[3][8] .operation_mode = "normal";
defparam \mem[3][8] .output_mode = "reg_only";
defparam \mem[3][8] .register_cascade_mode = "off";
defparam \mem[3][8] .sum_lutc_input = "datac";
defparam \mem[3][8] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X6_Y1_N6
maxv_lcell \mem[0][8] (
// Equation(s):
// \mem[0][8]~regout  = DFFEAS(GND, GLOBAL(\wr_clk~combout ), !GLOBAL(\clr~combout ), , \Decoder0~6_combout , \data_in~combout [8], , , VCC)

	.clk(\wr_clk~combout ),
	.dataa(vcc),
	.datab(vcc),
	.datac(\data_in~combout [8]),
	.datad(vcc),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~6_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\mem[0][8]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[0][8] .lut_mask = "0000";
defparam \mem[0][8] .operation_mode = "normal";
defparam \mem[0][8] .output_mode = "reg_only";
defparam \mem[0][8] .register_cascade_mode = "off";
defparam \mem[0][8] .sum_lutc_input = "datac";
defparam \mem[0][8] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X6_Y1_N7
maxv_lcell \mem[1][8] (
// Equation(s):
// \Mux7~2  = (\rd_addr~combout [1] & (\rd_addr~combout [0])) # (!\rd_addr~combout [1] & ((\rd_addr~combout [0] & (mem[1][8])) # (!\rd_addr~combout [0] & ((\mem[0][8]~regout )))))

	.clk(\wr_clk~combout ),
	.dataa(\rd_addr~combout [1]),
	.datab(\rd_addr~combout [0]),
	.datac(\data_in~combout [8]),
	.datad(\mem[0][8]~regout ),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~5_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(\Mux7~2 ),
	.regout(\mem[1][8]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[1][8] .lut_mask = "d9c8";
defparam \mem[1][8] .operation_mode = "normal";
defparam \mem[1][8] .output_mode = "comb_only";
defparam \mem[1][8] .register_cascade_mode = "off";
defparam \mem[1][8] .sum_lutc_input = "qfbk";
defparam \mem[1][8] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X5_Y1_N4
maxv_lcell \mem[2][8] (
// Equation(s):
// \Mux7~3  = (\rd_addr~combout [1] & ((\Mux7~2  & (\mem[3][8]~regout )) # (!\Mux7~2  & ((mem[2][8]))))) # (!\rd_addr~combout [1] & (((\Mux7~2 ))))

	.clk(\wr_clk~combout ),
	.dataa(\rd_addr~combout [1]),
	.datab(\mem[3][8]~regout ),
	.datac(\data_in~combout [8]),
	.datad(\Mux7~2 ),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~4_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(\Mux7~3 ),
	.regout(\mem[2][8]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[2][8] .lut_mask = "dda0";
defparam \mem[2][8] .operation_mode = "normal";
defparam \mem[2][8] .output_mode = "comb_only";
defparam \mem[2][8] .register_cascade_mode = "off";
defparam \mem[2][8] .sum_lutc_input = "qfbk";
defparam \mem[2][8] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X3_Y2_N4
maxv_lcell \mem[7][8] (
// Equation(s):
// \mem[7][8]~regout  = DFFEAS((((\data_in~combout [8]))), GLOBAL(\wr_clk~combout ), !GLOBAL(\clr~combout ), , \Decoder0~3_combout , , , , )

	.clk(\wr_clk~combout ),
	.dataa(vcc),
	.datab(vcc),
	.datac(vcc),
	.datad(\data_in~combout [8]),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(\Decoder0~3_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\mem[7][8]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[7][8] .lut_mask = "ff00";
defparam \mem[7][8] .operation_mode = "normal";
defparam \mem[7][8] .output_mode = "reg_only";
defparam \mem[7][8] .register_cascade_mode = "off";
defparam \mem[7][8] .sum_lutc_input = "datac";
defparam \mem[7][8] .synch_mode = "off";
// synopsys translate_on

// Location: LC_X3_Y2_N3
maxv_lcell \mem[4][8] (
// Equation(s):
// \mem[4][8]~regout  = DFFEAS((((\data_in~combout [8]))), GLOBAL(\wr_clk~combout ), !GLOBAL(\clr~combout ), , \Decoder0~2_combout , , , , )

	.clk(\wr_clk~combout ),
	.dataa(vcc),
	.datab(vcc),
	.datac(vcc),
	.datad(\data_in~combout [8]),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(\Decoder0~2_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\mem[4][8]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[4][8] .lut_mask = "ff00";
defparam \mem[4][8] .operation_mode = "normal";
defparam \mem[4][8] .output_mode = "reg_only";
defparam \mem[4][8] .register_cascade_mode = "off";
defparam \mem[4][8] .sum_lutc_input = "datac";
defparam \mem[4][8] .synch_mode = "off";
// synopsys translate_on

// Location: LC_X4_Y2_N9
maxv_lcell \mem[6][8] (
// Equation(s):
// \Mux7~0  = (\rd_addr~combout [1] & ((\rd_addr~combout [0]) # ((mem[6][8])))) # (!\rd_addr~combout [1] & (!\rd_addr~combout [0] & ((\mem[4][8]~regout ))))

	.clk(\wr_clk~combout ),
	.dataa(\rd_addr~combout [1]),
	.datab(\rd_addr~combout [0]),
	.datac(\data_in~combout [8]),
	.datad(\mem[4][8]~regout ),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~1_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(\Mux7~0 ),
	.regout(\mem[6][8]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[6][8] .lut_mask = "b9a8";
defparam \mem[6][8] .operation_mode = "normal";
defparam \mem[6][8] .output_mode = "comb_only";
defparam \mem[6][8] .register_cascade_mode = "off";
defparam \mem[6][8] .sum_lutc_input = "qfbk";
defparam \mem[6][8] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X4_Y2_N0
maxv_lcell \mem[5][8] (
// Equation(s):
// \Mux7~1  = (\rd_addr~combout [0] & ((\Mux7~0  & (\mem[7][8]~regout )) # (!\Mux7~0  & ((mem[5][8]))))) # (!\rd_addr~combout [0] & (((\Mux7~0 ))))

	.clk(\wr_clk~combout ),
	.dataa(\mem[7][8]~regout ),
	.datab(\rd_addr~combout [0]),
	.datac(\data_in~combout [8]),
	.datad(\Mux7~0 ),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~0_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(\Mux7~1 ),
	.regout(\mem[5][8]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[5][8] .lut_mask = "bbc0";
defparam \mem[5][8] .operation_mode = "normal";
defparam \mem[5][8] .output_mode = "comb_only";
defparam \mem[5][8] .register_cascade_mode = "off";
defparam \mem[5][8] .sum_lutc_input = "qfbk";
defparam \mem[5][8] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X5_Y1_N5
maxv_lcell \data_out[8]~reg0 (
// Equation(s):
// \data_out[8]~reg0_regout  = DFFEAS(((\rd_addr~combout [2] & ((\Mux7~1 ))) # (!\rd_addr~combout [2] & (\Mux7~3 ))), GLOBAL(\rd_clk~combout ), !GLOBAL(\clr~combout ), , \re~combout , , , , )

	.clk(\rd_clk~combout ),
	.dataa(vcc),
	.datab(\rd_addr~combout [2]),
	.datac(\Mux7~3 ),
	.datad(\Mux7~1 ),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(\re~combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\data_out[8]~reg0_regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \data_out[8]~reg0 .lut_mask = "fc30";
defparam \data_out[8]~reg0 .operation_mode = "normal";
defparam \data_out[8]~reg0 .output_mode = "reg_only";
defparam \data_out[8]~reg0 .register_cascade_mode = "off";
defparam \data_out[8]~reg0 .sum_lutc_input = "datac";
defparam \data_out[8]~reg0 .synch_mode = "off";
// synopsys translate_on

// Location: PIN_A10,	 I/O Standard: 3.3-V LVTTL,	 Current Strength: Default
maxv_io \data_in[9]~I (
	.datain(gnd),
	.oe(gnd),
	.combout(\data_in~combout [9]),
	.padio(data_in[9]));
// synopsys translate_off
defparam \data_in[9]~I .operation_mode = "input";
// synopsys translate_on

// Location: LC_X6_Y4_N4
maxv_lcell \mem[3][9] (
// Equation(s):
// \mem[3][9]~regout  = DFFEAS(GND, GLOBAL(\wr_clk~combout ), !GLOBAL(\clr~combout ), , \Decoder0~7_combout , \data_in~combout [9], , , VCC)

	.clk(\wr_clk~combout ),
	.dataa(vcc),
	.datab(vcc),
	.datac(\data_in~combout [9]),
	.datad(vcc),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~7_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\mem[3][9]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[3][9] .lut_mask = "0000";
defparam \mem[3][9] .operation_mode = "normal";
defparam \mem[3][9] .output_mode = "reg_only";
defparam \mem[3][9] .register_cascade_mode = "off";
defparam \mem[3][9] .sum_lutc_input = "datac";
defparam \mem[3][9] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X7_Y4_N4
maxv_lcell \mem[0][9] (
// Equation(s):
// \mem[0][9]~regout  = DFFEAS(GND, GLOBAL(\wr_clk~combout ), !GLOBAL(\clr~combout ), , \Decoder0~6_combout , \data_in~combout [9], , , VCC)

	.clk(\wr_clk~combout ),
	.dataa(vcc),
	.datab(vcc),
	.datac(\data_in~combout [9]),
	.datad(vcc),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~6_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\mem[0][9]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[0][9] .lut_mask = "0000";
defparam \mem[0][9] .operation_mode = "normal";
defparam \mem[0][9] .output_mode = "reg_only";
defparam \mem[0][9] .register_cascade_mode = "off";
defparam \mem[0][9] .sum_lutc_input = "datac";
defparam \mem[0][9] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X6_Y4_N7
maxv_lcell \mem[1][9] (
// Equation(s):
// \Mux6~2  = (\rd_addr~combout [0] & ((\rd_addr~combout [1]) # ((mem[1][9])))) # (!\rd_addr~combout [0] & (!\rd_addr~combout [1] & ((\mem[0][9]~regout ))))

	.clk(\wr_clk~combout ),
	.dataa(\rd_addr~combout [0]),
	.datab(\rd_addr~combout [1]),
	.datac(\data_in~combout [9]),
	.datad(\mem[0][9]~regout ),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~5_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(\Mux6~2 ),
	.regout(\mem[1][9]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[1][9] .lut_mask = "b9a8";
defparam \mem[1][9] .operation_mode = "normal";
defparam \mem[1][9] .output_mode = "comb_only";
defparam \mem[1][9] .register_cascade_mode = "off";
defparam \mem[1][9] .sum_lutc_input = "qfbk";
defparam \mem[1][9] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X5_Y4_N6
maxv_lcell \mem[2][9] (
// Equation(s):
// \Mux6~3  = (\rd_addr~combout [1] & ((\Mux6~2  & (\mem[3][9]~regout )) # (!\Mux6~2  & ((mem[2][9]))))) # (!\rd_addr~combout [1] & (((\Mux6~2 ))))

	.clk(\wr_clk~combout ),
	.dataa(\rd_addr~combout [1]),
	.datab(\mem[3][9]~regout ),
	.datac(\data_in~combout [9]),
	.datad(\Mux6~2 ),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~4_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(\Mux6~3 ),
	.regout(\mem[2][9]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[2][9] .lut_mask = "dda0";
defparam \mem[2][9] .operation_mode = "normal";
defparam \mem[2][9] .output_mode = "comb_only";
defparam \mem[2][9] .register_cascade_mode = "off";
defparam \mem[2][9] .sum_lutc_input = "qfbk";
defparam \mem[2][9] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X3_Y2_N8
maxv_lcell \mem[7][9] (
// Equation(s):
// \mem[7][9]~regout  = DFFEAS(GND, GLOBAL(\wr_clk~combout ), !GLOBAL(\clr~combout ), , \Decoder0~3_combout , \data_in~combout [9], , , VCC)

	.clk(\wr_clk~combout ),
	.dataa(vcc),
	.datab(vcc),
	.datac(\data_in~combout [9]),
	.datad(vcc),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~3_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\mem[7][9]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[7][9] .lut_mask = "0000";
defparam \mem[7][9] .operation_mode = "normal";
defparam \mem[7][9] .output_mode = "reg_only";
defparam \mem[7][9] .register_cascade_mode = "off";
defparam \mem[7][9] .sum_lutc_input = "datac";
defparam \mem[7][9] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X3_Y2_N0
maxv_lcell \mem[4][9] (
// Equation(s):
// \mem[4][9]~regout  = DFFEAS(GND, GLOBAL(\wr_clk~combout ), !GLOBAL(\clr~combout ), , \Decoder0~2_combout , \data_in~combout [9], , , VCC)

	.clk(\wr_clk~combout ),
	.dataa(vcc),
	.datab(vcc),
	.datac(\data_in~combout [9]),
	.datad(vcc),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~2_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\mem[4][9]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[4][9] .lut_mask = "0000";
defparam \mem[4][9] .operation_mode = "normal";
defparam \mem[4][9] .output_mode = "reg_only";
defparam \mem[4][9] .register_cascade_mode = "off";
defparam \mem[4][9] .sum_lutc_input = "datac";
defparam \mem[4][9] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X4_Y2_N3
maxv_lcell \mem[6][9] (
// Equation(s):
// \Mux6~0  = (\rd_addr~combout [0] & (\rd_addr~combout [1])) # (!\rd_addr~combout [0] & ((\rd_addr~combout [1] & (mem[6][9])) # (!\rd_addr~combout [1] & ((\mem[4][9]~regout )))))

	.clk(\wr_clk~combout ),
	.dataa(\rd_addr~combout [0]),
	.datab(\rd_addr~combout [1]),
	.datac(\data_in~combout [9]),
	.datad(\mem[4][9]~regout ),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~1_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(\Mux6~0 ),
	.regout(\mem[6][9]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[6][9] .lut_mask = "d9c8";
defparam \mem[6][9] .operation_mode = "normal";
defparam \mem[6][9] .output_mode = "comb_only";
defparam \mem[6][9] .register_cascade_mode = "off";
defparam \mem[6][9] .sum_lutc_input = "qfbk";
defparam \mem[6][9] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X4_Y2_N2
maxv_lcell \mem[5][9] (
// Equation(s):
// \Mux6~1  = (\rd_addr~combout [0] & ((\Mux6~0  & (\mem[7][9]~regout )) # (!\Mux6~0  & ((mem[5][9]))))) # (!\rd_addr~combout [0] & (((\Mux6~0 ))))

	.clk(\wr_clk~combout ),
	.dataa(\mem[7][9]~regout ),
	.datab(\rd_addr~combout [0]),
	.datac(\data_in~combout [9]),
	.datad(\Mux6~0 ),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~0_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(\Mux6~1 ),
	.regout(\mem[5][9]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[5][9] .lut_mask = "bbc0";
defparam \mem[5][9] .operation_mode = "normal";
defparam \mem[5][9] .output_mode = "comb_only";
defparam \mem[5][9] .register_cascade_mode = "off";
defparam \mem[5][9] .sum_lutc_input = "qfbk";
defparam \mem[5][9] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X5_Y4_N0
maxv_lcell \data_out[9]~reg0 (
// Equation(s):
// \data_out[9]~reg0_regout  = DFFEAS(((\rd_addr~combout [2] & ((\Mux6~1 ))) # (!\rd_addr~combout [2] & (\Mux6~3 ))), GLOBAL(\rd_clk~combout ), !GLOBAL(\clr~combout ), , \re~combout , , , , )

	.clk(\rd_clk~combout ),
	.dataa(vcc),
	.datab(\rd_addr~combout [2]),
	.datac(\Mux6~3 ),
	.datad(\Mux6~1 ),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(\re~combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\data_out[9]~reg0_regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \data_out[9]~reg0 .lut_mask = "fc30";
defparam \data_out[9]~reg0 .operation_mode = "normal";
defparam \data_out[9]~reg0 .output_mode = "reg_only";
defparam \data_out[9]~reg0 .register_cascade_mode = "off";
defparam \data_out[9]~reg0 .sum_lutc_input = "datac";
defparam \data_out[9]~reg0 .synch_mode = "off";
// synopsys translate_on

// Location: PIN_A6,	 I/O Standard: 3.3-V LVTTL,	 Current Strength: Default
maxv_io \data_in[10]~I (
	.datain(gnd),
	.oe(gnd),
	.combout(\data_in~combout [10]),
	.padio(data_in[10]));
// synopsys translate_off
defparam \data_in[10]~I .operation_mode = "input";
// synopsys translate_on

// Location: LC_X3_Y2_N1
maxv_lcell \mem[7][10] (
// Equation(s):
// \mem[7][10]~regout  = DFFEAS(GND, GLOBAL(\wr_clk~combout ), !GLOBAL(\clr~combout ), , \Decoder0~3_combout , \data_in~combout [10], , , VCC)

	.clk(\wr_clk~combout ),
	.dataa(vcc),
	.datab(vcc),
	.datac(\data_in~combout [10]),
	.datad(vcc),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~3_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\mem[7][10]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[7][10] .lut_mask = "0000";
defparam \mem[7][10] .operation_mode = "normal";
defparam \mem[7][10] .output_mode = "reg_only";
defparam \mem[7][10] .register_cascade_mode = "off";
defparam \mem[7][10] .sum_lutc_input = "datac";
defparam \mem[7][10] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X3_Y2_N2
maxv_lcell \mem[4][10] (
// Equation(s):
// \mem[4][10]~regout  = DFFEAS(GND, GLOBAL(\wr_clk~combout ), !GLOBAL(\clr~combout ), , \Decoder0~2_combout , \data_in~combout [10], , , VCC)

	.clk(\wr_clk~combout ),
	.dataa(vcc),
	.datab(vcc),
	.datac(\data_in~combout [10]),
	.datad(vcc),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~2_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\mem[4][10]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[4][10] .lut_mask = "0000";
defparam \mem[4][10] .operation_mode = "normal";
defparam \mem[4][10] .output_mode = "reg_only";
defparam \mem[4][10] .register_cascade_mode = "off";
defparam \mem[4][10] .sum_lutc_input = "datac";
defparam \mem[4][10] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X4_Y2_N5
maxv_lcell \mem[6][10] (
// Equation(s):
// \Mux5~0  = (\rd_addr~combout [0] & (\rd_addr~combout [1])) # (!\rd_addr~combout [0] & ((\rd_addr~combout [1] & (mem[6][10])) # (!\rd_addr~combout [1] & ((\mem[4][10]~regout )))))

	.clk(\wr_clk~combout ),
	.dataa(\rd_addr~combout [0]),
	.datab(\rd_addr~combout [1]),
	.datac(\data_in~combout [10]),
	.datad(\mem[4][10]~regout ),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~1_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(\Mux5~0 ),
	.regout(\mem[6][10]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[6][10] .lut_mask = "d9c8";
defparam \mem[6][10] .operation_mode = "normal";
defparam \mem[6][10] .output_mode = "comb_only";
defparam \mem[6][10] .register_cascade_mode = "off";
defparam \mem[6][10] .sum_lutc_input = "qfbk";
defparam \mem[6][10] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X4_Y2_N6
maxv_lcell \mem[5][10] (
// Equation(s):
// \Mux5~1  = (\rd_addr~combout [0] & ((\Mux5~0  & (\mem[7][10]~regout )) # (!\Mux5~0  & ((mem[5][10]))))) # (!\rd_addr~combout [0] & (((\Mux5~0 ))))

	.clk(\wr_clk~combout ),
	.dataa(\mem[7][10]~regout ),
	.datab(\rd_addr~combout [0]),
	.datac(\data_in~combout [10]),
	.datad(\Mux5~0 ),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~0_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(\Mux5~1 ),
	.regout(\mem[5][10]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[5][10] .lut_mask = "bbc0";
defparam \mem[5][10] .operation_mode = "normal";
defparam \mem[5][10] .output_mode = "comb_only";
defparam \mem[5][10] .register_cascade_mode = "off";
defparam \mem[5][10] .sum_lutc_input = "qfbk";
defparam \mem[5][10] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X4_Y4_N0
maxv_lcell \mem[3][10] (
// Equation(s):
// \mem[3][10]~regout  = DFFEAS(GND, GLOBAL(\wr_clk~combout ), !GLOBAL(\clr~combout ), , \Decoder0~7_combout , \data_in~combout [10], , , VCC)

	.clk(\wr_clk~combout ),
	.dataa(vcc),
	.datab(vcc),
	.datac(\data_in~combout [10]),
	.datad(vcc),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~7_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\mem[3][10]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[3][10] .lut_mask = "0000";
defparam \mem[3][10] .operation_mode = "normal";
defparam \mem[3][10] .output_mode = "reg_only";
defparam \mem[3][10] .register_cascade_mode = "off";
defparam \mem[3][10] .sum_lutc_input = "datac";
defparam \mem[3][10] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X6_Y2_N0
maxv_lcell \mem[0][10] (
// Equation(s):
// \mem[0][10]~regout  = DFFEAS(GND, GLOBAL(\wr_clk~combout ), !GLOBAL(\clr~combout ), , \Decoder0~6_combout , \data_in~combout [10], , , VCC)

	.clk(\wr_clk~combout ),
	.dataa(vcc),
	.datab(vcc),
	.datac(\data_in~combout [10]),
	.datad(vcc),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~6_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\mem[0][10]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[0][10] .lut_mask = "0000";
defparam \mem[0][10] .operation_mode = "normal";
defparam \mem[0][10] .output_mode = "reg_only";
defparam \mem[0][10] .register_cascade_mode = "off";
defparam \mem[0][10] .sum_lutc_input = "datac";
defparam \mem[0][10] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X6_Y2_N7
maxv_lcell \mem[1][10] (
// Equation(s):
// \Mux5~2  = (\rd_addr~combout [1] & (\rd_addr~combout [0])) # (!\rd_addr~combout [1] & ((\rd_addr~combout [0] & (mem[1][10])) # (!\rd_addr~combout [0] & ((\mem[0][10]~regout )))))

	.clk(\wr_clk~combout ),
	.dataa(\rd_addr~combout [1]),
	.datab(\rd_addr~combout [0]),
	.datac(\data_in~combout [10]),
	.datad(\mem[0][10]~regout ),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~5_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(\Mux5~2 ),
	.regout(\mem[1][10]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[1][10] .lut_mask = "d9c8";
defparam \mem[1][10] .operation_mode = "normal";
defparam \mem[1][10] .output_mode = "comb_only";
defparam \mem[1][10] .register_cascade_mode = "off";
defparam \mem[1][10] .sum_lutc_input = "qfbk";
defparam \mem[1][10] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X5_Y2_N2
maxv_lcell \mem[2][10] (
// Equation(s):
// \Mux5~3  = (\rd_addr~combout [1] & ((\Mux5~2  & (\mem[3][10]~regout )) # (!\Mux5~2  & ((mem[2][10]))))) # (!\rd_addr~combout [1] & (((\Mux5~2 ))))

	.clk(\wr_clk~combout ),
	.dataa(\rd_addr~combout [1]),
	.datab(\mem[3][10]~regout ),
	.datac(\data_in~combout [10]),
	.datad(\Mux5~2 ),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~4_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(\Mux5~3 ),
	.regout(\mem[2][10]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[2][10] .lut_mask = "dda0";
defparam \mem[2][10] .operation_mode = "normal";
defparam \mem[2][10] .output_mode = "comb_only";
defparam \mem[2][10] .register_cascade_mode = "off";
defparam \mem[2][10] .sum_lutc_input = "qfbk";
defparam \mem[2][10] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X5_Y2_N8
maxv_lcell \data_out[10]~reg0 (
// Equation(s):
// \data_out[10]~reg0_regout  = DFFEAS(((\rd_addr~combout [2] & (\Mux5~1 )) # (!\rd_addr~combout [2] & ((\Mux5~3 )))), GLOBAL(\rd_clk~combout ), !GLOBAL(\clr~combout ), , \re~combout , , , , )

	.clk(\rd_clk~combout ),
	.dataa(vcc),
	.datab(\rd_addr~combout [2]),
	.datac(\Mux5~1 ),
	.datad(\Mux5~3 ),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(\re~combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\data_out[10]~reg0_regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \data_out[10]~reg0 .lut_mask = "f3c0";
defparam \data_out[10]~reg0 .operation_mode = "normal";
defparam \data_out[10]~reg0 .output_mode = "reg_only";
defparam \data_out[10]~reg0 .register_cascade_mode = "off";
defparam \data_out[10]~reg0 .sum_lutc_input = "datac";
defparam \data_out[10]~reg0 .synch_mode = "off";
// synopsys translate_on

// Location: PIN_J5,	 I/O Standard: 3.3-V LVTTL,	 Current Strength: Default
maxv_io \data_in[11]~I (
	.datain(gnd),
	.oe(gnd),
	.combout(\data_in~combout [11]),
	.padio(data_in[11]));
// synopsys translate_off
defparam \data_in[11]~I .operation_mode = "input";
// synopsys translate_on

// Location: LC_X3_Y3_N6
maxv_lcell \mem[7][11] (
// Equation(s):
// \mem[7][11]~regout  = DFFEAS((((\data_in~combout [11]))), GLOBAL(\wr_clk~combout ), !GLOBAL(\clr~combout ), , \Decoder0~3_combout , , , , )

	.clk(\wr_clk~combout ),
	.dataa(vcc),
	.datab(vcc),
	.datac(vcc),
	.datad(\data_in~combout [11]),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(\Decoder0~3_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\mem[7][11]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[7][11] .lut_mask = "ff00";
defparam \mem[7][11] .operation_mode = "normal";
defparam \mem[7][11] .output_mode = "reg_only";
defparam \mem[7][11] .register_cascade_mode = "off";
defparam \mem[7][11] .sum_lutc_input = "datac";
defparam \mem[7][11] .synch_mode = "off";
// synopsys translate_on

// Location: LC_X3_Y3_N7
maxv_lcell \mem[4][11] (
// Equation(s):
// \mem[4][11]~regout  = DFFEAS((((\data_in~combout [11]))), GLOBAL(\wr_clk~combout ), !GLOBAL(\clr~combout ), , \Decoder0~2_combout , , , , )

	.clk(\wr_clk~combout ),
	.dataa(vcc),
	.datab(vcc),
	.datac(vcc),
	.datad(\data_in~combout [11]),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(\Decoder0~2_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\mem[4][11]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[4][11] .lut_mask = "ff00";
defparam \mem[4][11] .operation_mode = "normal";
defparam \mem[4][11] .output_mode = "reg_only";
defparam \mem[4][11] .register_cascade_mode = "off";
defparam \mem[4][11] .sum_lutc_input = "datac";
defparam \mem[4][11] .synch_mode = "off";
// synopsys translate_on

// Location: LC_X4_Y3_N9
maxv_lcell \mem[6][11] (
// Equation(s):
// \Mux4~0  = (\rd_addr~combout [1] & ((\rd_addr~combout [0]) # ((mem[6][11])))) # (!\rd_addr~combout [1] & (!\rd_addr~combout [0] & ((\mem[4][11]~regout ))))

	.clk(\wr_clk~combout ),
	.dataa(\rd_addr~combout [1]),
	.datab(\rd_addr~combout [0]),
	.datac(\data_in~combout [11]),
	.datad(\mem[4][11]~regout ),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~1_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(\Mux4~0 ),
	.regout(\mem[6][11]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[6][11] .lut_mask = "b9a8";
defparam \mem[6][11] .operation_mode = "normal";
defparam \mem[6][11] .output_mode = "comb_only";
defparam \mem[6][11] .register_cascade_mode = "off";
defparam \mem[6][11] .sum_lutc_input = "qfbk";
defparam \mem[6][11] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X4_Y3_N2
maxv_lcell \mem[5][11] (
// Equation(s):
// \Mux4~1  = (\rd_addr~combout [0] & ((\Mux4~0  & (\mem[7][11]~regout )) # (!\Mux4~0  & ((mem[5][11]))))) # (!\rd_addr~combout [0] & (((\Mux4~0 ))))

	.clk(\wr_clk~combout ),
	.dataa(\rd_addr~combout [0]),
	.datab(\mem[7][11]~regout ),
	.datac(\data_in~combout [11]),
	.datad(\Mux4~0 ),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~0_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(\Mux4~1 ),
	.regout(\mem[5][11]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[5][11] .lut_mask = "dda0";
defparam \mem[5][11] .operation_mode = "normal";
defparam \mem[5][11] .output_mode = "comb_only";
defparam \mem[5][11] .register_cascade_mode = "off";
defparam \mem[5][11] .sum_lutc_input = "qfbk";
defparam \mem[5][11] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X6_Y4_N0
maxv_lcell \mem[3][11] (
// Equation(s):
// \mem[3][11]~regout  = DFFEAS(GND, GLOBAL(\wr_clk~combout ), !GLOBAL(\clr~combout ), , \Decoder0~7_combout , \data_in~combout [11], , , VCC)

	.clk(\wr_clk~combout ),
	.dataa(vcc),
	.datab(vcc),
	.datac(\data_in~combout [11]),
	.datad(vcc),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~7_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\mem[3][11]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[3][11] .lut_mask = "0000";
defparam \mem[3][11] .operation_mode = "normal";
defparam \mem[3][11] .output_mode = "reg_only";
defparam \mem[3][11] .register_cascade_mode = "off";
defparam \mem[3][11] .sum_lutc_input = "datac";
defparam \mem[3][11] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X6_Y1_N9
maxv_lcell \mem[0][11] (
// Equation(s):
// \mem[0][11]~regout  = DFFEAS(GND, GLOBAL(\wr_clk~combout ), !GLOBAL(\clr~combout ), , \Decoder0~6_combout , \data_in~combout [11], , , VCC)

	.clk(\wr_clk~combout ),
	.dataa(vcc),
	.datab(vcc),
	.datac(\data_in~combout [11]),
	.datad(vcc),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~6_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\mem[0][11]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[0][11] .lut_mask = "0000";
defparam \mem[0][11] .operation_mode = "normal";
defparam \mem[0][11] .output_mode = "reg_only";
defparam \mem[0][11] .register_cascade_mode = "off";
defparam \mem[0][11] .sum_lutc_input = "datac";
defparam \mem[0][11] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X6_Y1_N1
maxv_lcell \mem[1][11] (
// Equation(s):
// \Mux4~2  = (\rd_addr~combout [1] & (\rd_addr~combout [0])) # (!\rd_addr~combout [1] & ((\rd_addr~combout [0] & (mem[1][11])) # (!\rd_addr~combout [0] & ((\mem[0][11]~regout )))))

	.clk(\wr_clk~combout ),
	.dataa(\rd_addr~combout [1]),
	.datab(\rd_addr~combout [0]),
	.datac(\data_in~combout [11]),
	.datad(\mem[0][11]~regout ),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~5_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(\Mux4~2 ),
	.regout(\mem[1][11]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[1][11] .lut_mask = "d9c8";
defparam \mem[1][11] .operation_mode = "normal";
defparam \mem[1][11] .output_mode = "comb_only";
defparam \mem[1][11] .register_cascade_mode = "off";
defparam \mem[1][11] .sum_lutc_input = "qfbk";
defparam \mem[1][11] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X5_Y2_N5
maxv_lcell \mem[2][11] (
// Equation(s):
// \Mux4~3  = (\rd_addr~combout [1] & ((\Mux4~2  & (\mem[3][11]~regout )) # (!\Mux4~2  & ((mem[2][11]))))) # (!\rd_addr~combout [1] & (((\Mux4~2 ))))

	.clk(\wr_clk~combout ),
	.dataa(\mem[3][11]~regout ),
	.datab(\rd_addr~combout [1]),
	.datac(\data_in~combout [11]),
	.datad(\Mux4~2 ),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~4_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(\Mux4~3 ),
	.regout(\mem[2][11]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[2][11] .lut_mask = "bbc0";
defparam \mem[2][11] .operation_mode = "normal";
defparam \mem[2][11] .output_mode = "comb_only";
defparam \mem[2][11] .register_cascade_mode = "off";
defparam \mem[2][11] .sum_lutc_input = "qfbk";
defparam \mem[2][11] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X5_Y2_N6
maxv_lcell \data_out[11]~reg0 (
// Equation(s):
// \data_out[11]~reg0_regout  = DFFEAS(((\rd_addr~combout [2] & (\Mux4~1 )) # (!\rd_addr~combout [2] & ((\Mux4~3 )))), GLOBAL(\rd_clk~combout ), !GLOBAL(\clr~combout ), , \re~combout , , , , )

	.clk(\rd_clk~combout ),
	.dataa(vcc),
	.datab(\rd_addr~combout [2]),
	.datac(\Mux4~1 ),
	.datad(\Mux4~3 ),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(\re~combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\data_out[11]~reg0_regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \data_out[11]~reg0 .lut_mask = "f3c0";
defparam \data_out[11]~reg0 .operation_mode = "normal";
defparam \data_out[11]~reg0 .output_mode = "reg_only";
defparam \data_out[11]~reg0 .register_cascade_mode = "off";
defparam \data_out[11]~reg0 .sum_lutc_input = "datac";
defparam \data_out[11]~reg0 .synch_mode = "off";
// synopsys translate_on

// Location: PIN_B7,	 I/O Standard: 3.3-V LVTTL,	 Current Strength: Default
maxv_io \data_in[12]~I (
	.datain(gnd),
	.oe(gnd),
	.combout(\data_in~combout [12]),
	.padio(data_in[12]));
// synopsys translate_off
defparam \data_in[12]~I .operation_mode = "input";
// synopsys translate_on

// Location: LC_X3_Y1_N6
maxv_lcell \mem[7][12] (
// Equation(s):
// \mem[7][12]~regout  = DFFEAS(GND, GLOBAL(\wr_clk~combout ), !GLOBAL(\clr~combout ), , \Decoder0~3_combout , \data_in~combout [12], , , VCC)

	.clk(\wr_clk~combout ),
	.dataa(vcc),
	.datab(vcc),
	.datac(\data_in~combout [12]),
	.datad(vcc),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~3_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\mem[7][12]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[7][12] .lut_mask = "0000";
defparam \mem[7][12] .operation_mode = "normal";
defparam \mem[7][12] .output_mode = "reg_only";
defparam \mem[7][12] .register_cascade_mode = "off";
defparam \mem[7][12] .sum_lutc_input = "datac";
defparam \mem[7][12] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X3_Y1_N7
maxv_lcell \mem[4][12] (
// Equation(s):
// \mem[4][12]~regout  = DFFEAS(GND, GLOBAL(\wr_clk~combout ), !GLOBAL(\clr~combout ), , \Decoder0~2_combout , \data_in~combout [12], , , VCC)

	.clk(\wr_clk~combout ),
	.dataa(vcc),
	.datab(vcc),
	.datac(\data_in~combout [12]),
	.datad(vcc),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~2_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\mem[4][12]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[4][12] .lut_mask = "0000";
defparam \mem[4][12] .operation_mode = "normal";
defparam \mem[4][12] .output_mode = "reg_only";
defparam \mem[4][12] .register_cascade_mode = "off";
defparam \mem[4][12] .sum_lutc_input = "datac";
defparam \mem[4][12] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X4_Y1_N4
maxv_lcell \mem[6][12] (
// Equation(s):
// \Mux3~0  = (\rd_addr~combout [1] & ((\rd_addr~combout [0]) # ((mem[6][12])))) # (!\rd_addr~combout [1] & (!\rd_addr~combout [0] & ((\mem[4][12]~regout ))))

	.clk(\wr_clk~combout ),
	.dataa(\rd_addr~combout [1]),
	.datab(\rd_addr~combout [0]),
	.datac(\data_in~combout [12]),
	.datad(\mem[4][12]~regout ),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~1_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(\Mux3~0 ),
	.regout(\mem[6][12]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[6][12] .lut_mask = "b9a8";
defparam \mem[6][12] .operation_mode = "normal";
defparam \mem[6][12] .output_mode = "comb_only";
defparam \mem[6][12] .register_cascade_mode = "off";
defparam \mem[6][12] .sum_lutc_input = "qfbk";
defparam \mem[6][12] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X4_Y1_N5
maxv_lcell \mem[5][12] (
// Equation(s):
// \Mux3~1  = (\rd_addr~combout [0] & ((\Mux3~0  & (\mem[7][12]~regout )) # (!\Mux3~0  & ((mem[5][12]))))) # (!\rd_addr~combout [0] & (((\Mux3~0 ))))

	.clk(\wr_clk~combout ),
	.dataa(\rd_addr~combout [0]),
	.datab(\mem[7][12]~regout ),
	.datac(\data_in~combout [12]),
	.datad(\Mux3~0 ),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~0_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(\Mux3~1 ),
	.regout(\mem[5][12]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[5][12] .lut_mask = "dda0";
defparam \mem[5][12] .operation_mode = "normal";
defparam \mem[5][12] .output_mode = "comb_only";
defparam \mem[5][12] .register_cascade_mode = "off";
defparam \mem[5][12] .sum_lutc_input = "qfbk";
defparam \mem[5][12] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X4_Y4_N4
maxv_lcell \mem[3][12] (
// Equation(s):
// \mem[3][12]~regout  = DFFEAS(GND, GLOBAL(\wr_clk~combout ), !GLOBAL(\clr~combout ), , \Decoder0~7_combout , \data_in~combout [12], , , VCC)

	.clk(\wr_clk~combout ),
	.dataa(vcc),
	.datab(vcc),
	.datac(\data_in~combout [12]),
	.datad(vcc),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~7_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\mem[3][12]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[3][12] .lut_mask = "0000";
defparam \mem[3][12] .operation_mode = "normal";
defparam \mem[3][12] .output_mode = "reg_only";
defparam \mem[3][12] .register_cascade_mode = "off";
defparam \mem[3][12] .sum_lutc_input = "datac";
defparam \mem[3][12] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X6_Y3_N2
maxv_lcell \mem[0][12] (
// Equation(s):
// \mem[0][12]~regout  = DFFEAS(GND, GLOBAL(\wr_clk~combout ), !GLOBAL(\clr~combout ), , \Decoder0~6_combout , \data_in~combout [12], , , VCC)

	.clk(\wr_clk~combout ),
	.dataa(vcc),
	.datab(vcc),
	.datac(\data_in~combout [12]),
	.datad(vcc),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~6_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\mem[0][12]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[0][12] .lut_mask = "0000";
defparam \mem[0][12] .operation_mode = "normal";
defparam \mem[0][12] .output_mode = "reg_only";
defparam \mem[0][12] .register_cascade_mode = "off";
defparam \mem[0][12] .sum_lutc_input = "datac";
defparam \mem[0][12] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X6_Y3_N7
maxv_lcell \mem[1][12] (
// Equation(s):
// \Mux3~2  = (\rd_addr~combout [1] & (\rd_addr~combout [0])) # (!\rd_addr~combout [1] & ((\rd_addr~combout [0] & (mem[1][12])) # (!\rd_addr~combout [0] & ((\mem[0][12]~regout )))))

	.clk(\wr_clk~combout ),
	.dataa(\rd_addr~combout [1]),
	.datab(\rd_addr~combout [0]),
	.datac(\data_in~combout [12]),
	.datad(\mem[0][12]~regout ),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~5_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(\Mux3~2 ),
	.regout(\mem[1][12]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[1][12] .lut_mask = "d9c8";
defparam \mem[1][12] .operation_mode = "normal";
defparam \mem[1][12] .output_mode = "comb_only";
defparam \mem[1][12] .register_cascade_mode = "off";
defparam \mem[1][12] .sum_lutc_input = "qfbk";
defparam \mem[1][12] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X5_Y2_N3
maxv_lcell \mem[2][12] (
// Equation(s):
// \Mux3~3  = (\rd_addr~combout [1] & ((\Mux3~2  & (\mem[3][12]~regout )) # (!\Mux3~2  & ((mem[2][12]))))) # (!\rd_addr~combout [1] & (((\Mux3~2 ))))

	.clk(\wr_clk~combout ),
	.dataa(\rd_addr~combout [1]),
	.datab(\mem[3][12]~regout ),
	.datac(\data_in~combout [12]),
	.datad(\Mux3~2 ),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~4_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(\Mux3~3 ),
	.regout(\mem[2][12]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[2][12] .lut_mask = "dda0";
defparam \mem[2][12] .operation_mode = "normal";
defparam \mem[2][12] .output_mode = "comb_only";
defparam \mem[2][12] .register_cascade_mode = "off";
defparam \mem[2][12] .sum_lutc_input = "qfbk";
defparam \mem[2][12] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X5_Y2_N4
maxv_lcell \data_out[12]~reg0 (
// Equation(s):
// \data_out[12]~reg0_regout  = DFFEAS(((\rd_addr~combout [2] & (\Mux3~1 )) # (!\rd_addr~combout [2] & ((\Mux3~3 )))), GLOBAL(\rd_clk~combout ), !GLOBAL(\clr~combout ), , \re~combout , , , , )

	.clk(\rd_clk~combout ),
	.dataa(vcc),
	.datab(\rd_addr~combout [2]),
	.datac(\Mux3~1 ),
	.datad(\Mux3~3 ),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(\re~combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\data_out[12]~reg0_regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \data_out[12]~reg0 .lut_mask = "f3c0";
defparam \data_out[12]~reg0 .operation_mode = "normal";
defparam \data_out[12]~reg0 .output_mode = "reg_only";
defparam \data_out[12]~reg0 .register_cascade_mode = "off";
defparam \data_out[12]~reg0 .sum_lutc_input = "datac";
defparam \data_out[12]~reg0 .synch_mode = "off";
// synopsys translate_on

// Location: PIN_A3,	 I/O Standard: 3.3-V LVTTL,	 Current Strength: Default
maxv_io \data_in[13]~I (
	.datain(gnd),
	.oe(gnd),
	.combout(\data_in~combout [13]),
	.padio(data_in[13]));
// synopsys translate_off
defparam \data_in[13]~I .operation_mode = "input";
// synopsys translate_on

// Location: LC_X3_Y2_N6
maxv_lcell \mem[7][13] (
// Equation(s):
// \mem[7][13]~regout  = DFFEAS(GND, GLOBAL(\wr_clk~combout ), !GLOBAL(\clr~combout ), , \Decoder0~3_combout , \data_in~combout [13], , , VCC)

	.clk(\wr_clk~combout ),
	.dataa(vcc),
	.datab(vcc),
	.datac(\data_in~combout [13]),
	.datad(vcc),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~3_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\mem[7][13]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[7][13] .lut_mask = "0000";
defparam \mem[7][13] .operation_mode = "normal";
defparam \mem[7][13] .output_mode = "reg_only";
defparam \mem[7][13] .register_cascade_mode = "off";
defparam \mem[7][13] .sum_lutc_input = "datac";
defparam \mem[7][13] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X3_Y2_N7
maxv_lcell \mem[4][13] (
// Equation(s):
// \mem[4][13]~regout  = DFFEAS(GND, GLOBAL(\wr_clk~combout ), !GLOBAL(\clr~combout ), , \Decoder0~2_combout , \data_in~combout [13], , , VCC)

	.clk(\wr_clk~combout ),
	.dataa(vcc),
	.datab(vcc),
	.datac(\data_in~combout [13]),
	.datad(vcc),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~2_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\mem[4][13]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[4][13] .lut_mask = "0000";
defparam \mem[4][13] .operation_mode = "normal";
defparam \mem[4][13] .output_mode = "reg_only";
defparam \mem[4][13] .register_cascade_mode = "off";
defparam \mem[4][13] .sum_lutc_input = "datac";
defparam \mem[4][13] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X4_Y2_N7
maxv_lcell \mem[6][13] (
// Equation(s):
// \Mux2~0  = (\rd_addr~combout [0] & (\rd_addr~combout [1])) # (!\rd_addr~combout [0] & ((\rd_addr~combout [1] & (mem[6][13])) # (!\rd_addr~combout [1] & ((\mem[4][13]~regout )))))

	.clk(\wr_clk~combout ),
	.dataa(\rd_addr~combout [0]),
	.datab(\rd_addr~combout [1]),
	.datac(\data_in~combout [13]),
	.datad(\mem[4][13]~regout ),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~1_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(\Mux2~0 ),
	.regout(\mem[6][13]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[6][13] .lut_mask = "d9c8";
defparam \mem[6][13] .operation_mode = "normal";
defparam \mem[6][13] .output_mode = "comb_only";
defparam \mem[6][13] .register_cascade_mode = "off";
defparam \mem[6][13] .sum_lutc_input = "qfbk";
defparam \mem[6][13] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X4_Y2_N8
maxv_lcell \mem[5][13] (
// Equation(s):
// \Mux2~1  = (\rd_addr~combout [0] & ((\Mux2~0  & (\mem[7][13]~regout )) # (!\Mux2~0  & ((mem[5][13]))))) # (!\rd_addr~combout [0] & (((\Mux2~0 ))))

	.clk(\wr_clk~combout ),
	.dataa(\rd_addr~combout [0]),
	.datab(\mem[7][13]~regout ),
	.datac(\data_in~combout [13]),
	.datad(\Mux2~0 ),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~0_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(\Mux2~1 ),
	.regout(\mem[5][13]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[5][13] .lut_mask = "dda0";
defparam \mem[5][13] .operation_mode = "normal";
defparam \mem[5][13] .output_mode = "comb_only";
defparam \mem[5][13] .register_cascade_mode = "off";
defparam \mem[5][13] .sum_lutc_input = "qfbk";
defparam \mem[5][13] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X6_Y2_N6
maxv_lcell \mem[0][13] (
// Equation(s):
// \mem[0][13]~regout  = DFFEAS(GND, GLOBAL(\wr_clk~combout ), !GLOBAL(\clr~combout ), , \Decoder0~6_combout , \data_in~combout [13], , , VCC)

	.clk(\wr_clk~combout ),
	.dataa(vcc),
	.datab(vcc),
	.datac(\data_in~combout [13]),
	.datad(vcc),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~6_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\mem[0][13]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[0][13] .lut_mask = "0000";
defparam \mem[0][13] .operation_mode = "normal";
defparam \mem[0][13] .output_mode = "reg_only";
defparam \mem[0][13] .register_cascade_mode = "off";
defparam \mem[0][13] .sum_lutc_input = "datac";
defparam \mem[0][13] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X6_Y2_N5
maxv_lcell \mem[1][13] (
// Equation(s):
// \Mux2~2  = (\rd_addr~combout [1] & (\rd_addr~combout [0])) # (!\rd_addr~combout [1] & ((\rd_addr~combout [0] & (mem[1][13])) # (!\rd_addr~combout [0] & ((\mem[0][13]~regout )))))

	.clk(\wr_clk~combout ),
	.dataa(\rd_addr~combout [1]),
	.datab(\rd_addr~combout [0]),
	.datac(\data_in~combout [13]),
	.datad(\mem[0][13]~regout ),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~5_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(\Mux2~2 ),
	.regout(\mem[1][13]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[1][13] .lut_mask = "d9c8";
defparam \mem[1][13] .operation_mode = "normal";
defparam \mem[1][13] .output_mode = "comb_only";
defparam \mem[1][13] .register_cascade_mode = "off";
defparam \mem[1][13] .sum_lutc_input = "qfbk";
defparam \mem[1][13] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X4_Y4_N3
maxv_lcell \mem[3][13] (
// Equation(s):
// \mem[3][13]~regout  = DFFEAS(GND, GLOBAL(\wr_clk~combout ), !GLOBAL(\clr~combout ), , \Decoder0~7_combout , \data_in~combout [13], , , VCC)

	.clk(\wr_clk~combout ),
	.dataa(vcc),
	.datab(vcc),
	.datac(\data_in~combout [13]),
	.datad(vcc),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~7_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\mem[3][13]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[3][13] .lut_mask = "0000";
defparam \mem[3][13] .operation_mode = "normal";
defparam \mem[3][13] .output_mode = "reg_only";
defparam \mem[3][13] .register_cascade_mode = "off";
defparam \mem[3][13] .sum_lutc_input = "datac";
defparam \mem[3][13] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X5_Y2_N9
maxv_lcell \mem[2][13] (
// Equation(s):
// \Mux2~3  = (\rd_addr~combout [1] & ((\Mux2~2  & ((\mem[3][13]~regout ))) # (!\Mux2~2  & (mem[2][13])))) # (!\rd_addr~combout [1] & (\Mux2~2 ))

	.clk(\wr_clk~combout ),
	.dataa(\rd_addr~combout [1]),
	.datab(\Mux2~2 ),
	.datac(\data_in~combout [13]),
	.datad(\mem[3][13]~regout ),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~4_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(\Mux2~3 ),
	.regout(\mem[2][13]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[2][13] .lut_mask = "ec64";
defparam \mem[2][13] .operation_mode = "normal";
defparam \mem[2][13] .output_mode = "comb_only";
defparam \mem[2][13] .register_cascade_mode = "off";
defparam \mem[2][13] .sum_lutc_input = "qfbk";
defparam \mem[2][13] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X5_Y2_N7
maxv_lcell \data_out[13]~reg0 (
// Equation(s):
// \data_out[13]~reg0_regout  = DFFEAS(((\rd_addr~combout [2] & (\Mux2~1 )) # (!\rd_addr~combout [2] & ((\Mux2~3 )))), GLOBAL(\rd_clk~combout ), !GLOBAL(\clr~combout ), , \re~combout , , , , )

	.clk(\rd_clk~combout ),
	.dataa(vcc),
	.datab(\rd_addr~combout [2]),
	.datac(\Mux2~1 ),
	.datad(\Mux2~3 ),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(\re~combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\data_out[13]~reg0_regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \data_out[13]~reg0 .lut_mask = "f3c0";
defparam \data_out[13]~reg0 .operation_mode = "normal";
defparam \data_out[13]~reg0 .output_mode = "reg_only";
defparam \data_out[13]~reg0 .register_cascade_mode = "off";
defparam \data_out[13]~reg0 .sum_lutc_input = "datac";
defparam \data_out[13]~reg0 .synch_mode = "off";
// synopsys translate_on

// Location: PIN_A9,	 I/O Standard: 3.3-V LVTTL,	 Current Strength: Default
maxv_io \data_in[14]~I (
	.datain(gnd),
	.oe(gnd),
	.combout(\data_in~combout [14]),
	.padio(data_in[14]));
// synopsys translate_off
defparam \data_in[14]~I .operation_mode = "input";
// synopsys translate_on

// Location: LC_X3_Y2_N9
maxv_lcell \mem[7][14] (
// Equation(s):
// \mem[7][14]~regout  = DFFEAS(GND, GLOBAL(\wr_clk~combout ), !GLOBAL(\clr~combout ), , \Decoder0~3_combout , \data_in~combout [14], , , VCC)

	.clk(\wr_clk~combout ),
	.dataa(vcc),
	.datab(vcc),
	.datac(\data_in~combout [14]),
	.datad(vcc),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~3_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\mem[7][14]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[7][14] .lut_mask = "0000";
defparam \mem[7][14] .operation_mode = "normal";
defparam \mem[7][14] .output_mode = "reg_only";
defparam \mem[7][14] .register_cascade_mode = "off";
defparam \mem[7][14] .sum_lutc_input = "datac";
defparam \mem[7][14] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X3_Y2_N5
maxv_lcell \mem[4][14] (
// Equation(s):
// \mem[4][14]~regout  = DFFEAS(GND, GLOBAL(\wr_clk~combout ), !GLOBAL(\clr~combout ), , \Decoder0~2_combout , \data_in~combout [14], , , VCC)

	.clk(\wr_clk~combout ),
	.dataa(vcc),
	.datab(vcc),
	.datac(\data_in~combout [14]),
	.datad(vcc),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~2_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\mem[4][14]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[4][14] .lut_mask = "0000";
defparam \mem[4][14] .operation_mode = "normal";
defparam \mem[4][14] .output_mode = "reg_only";
defparam \mem[4][14] .register_cascade_mode = "off";
defparam \mem[4][14] .sum_lutc_input = "datac";
defparam \mem[4][14] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X4_Y2_N4
maxv_lcell \mem[6][14] (
// Equation(s):
// \Mux1~0  = (\rd_addr~combout [0] & (\rd_addr~combout [1])) # (!\rd_addr~combout [0] & ((\rd_addr~combout [1] & (mem[6][14])) # (!\rd_addr~combout [1] & ((\mem[4][14]~regout )))))

	.clk(\wr_clk~combout ),
	.dataa(\rd_addr~combout [0]),
	.datab(\rd_addr~combout [1]),
	.datac(\data_in~combout [14]),
	.datad(\mem[4][14]~regout ),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~1_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(\Mux1~0 ),
	.regout(\mem[6][14]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[6][14] .lut_mask = "d9c8";
defparam \mem[6][14] .operation_mode = "normal";
defparam \mem[6][14] .output_mode = "comb_only";
defparam \mem[6][14] .register_cascade_mode = "off";
defparam \mem[6][14] .sum_lutc_input = "qfbk";
defparam \mem[6][14] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X4_Y2_N1
maxv_lcell \mem[5][14] (
// Equation(s):
// \Mux1~1  = (\rd_addr~combout [0] & ((\Mux1~0  & (\mem[7][14]~regout )) # (!\Mux1~0  & ((mem[5][14]))))) # (!\rd_addr~combout [0] & (((\Mux1~0 ))))

	.clk(\wr_clk~combout ),
	.dataa(\mem[7][14]~regout ),
	.datab(\rd_addr~combout [0]),
	.datac(\data_in~combout [14]),
	.datad(\Mux1~0 ),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~0_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(\Mux1~1 ),
	.regout(\mem[5][14]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[5][14] .lut_mask = "bbc0";
defparam \mem[5][14] .operation_mode = "normal";
defparam \mem[5][14] .output_mode = "comb_only";
defparam \mem[5][14] .register_cascade_mode = "off";
defparam \mem[5][14] .sum_lutc_input = "qfbk";
defparam \mem[5][14] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X4_Y4_N7
maxv_lcell \mem[3][14] (
// Equation(s):
// \mem[3][14]~regout  = DFFEAS(GND, GLOBAL(\wr_clk~combout ), !GLOBAL(\clr~combout ), , \Decoder0~7_combout , \data_in~combout [14], , , VCC)

	.clk(\wr_clk~combout ),
	.dataa(vcc),
	.datab(vcc),
	.datac(\data_in~combout [14]),
	.datad(vcc),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~7_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\mem[3][14]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[3][14] .lut_mask = "0000";
defparam \mem[3][14] .operation_mode = "normal";
defparam \mem[3][14] .output_mode = "reg_only";
defparam \mem[3][14] .register_cascade_mode = "off";
defparam \mem[3][14] .sum_lutc_input = "datac";
defparam \mem[3][14] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X6_Y3_N8
maxv_lcell \mem[0][14] (
// Equation(s):
// \mem[0][14]~regout  = DFFEAS(GND, GLOBAL(\wr_clk~combout ), !GLOBAL(\clr~combout ), , \Decoder0~6_combout , \data_in~combout [14], , , VCC)

	.clk(\wr_clk~combout ),
	.dataa(vcc),
	.datab(vcc),
	.datac(\data_in~combout [14]),
	.datad(vcc),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~6_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\mem[0][14]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[0][14] .lut_mask = "0000";
defparam \mem[0][14] .operation_mode = "normal";
defparam \mem[0][14] .output_mode = "reg_only";
defparam \mem[0][14] .register_cascade_mode = "off";
defparam \mem[0][14] .sum_lutc_input = "datac";
defparam \mem[0][14] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X6_Y3_N9
maxv_lcell \mem[1][14] (
// Equation(s):
// \Mux1~2  = (\rd_addr~combout [1] & (\rd_addr~combout [0])) # (!\rd_addr~combout [1] & ((\rd_addr~combout [0] & (mem[1][14])) # (!\rd_addr~combout [0] & ((\mem[0][14]~regout )))))

	.clk(\wr_clk~combout ),
	.dataa(\rd_addr~combout [1]),
	.datab(\rd_addr~combout [0]),
	.datac(\data_in~combout [14]),
	.datad(\mem[0][14]~regout ),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~5_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(\Mux1~2 ),
	.regout(\mem[1][14]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[1][14] .lut_mask = "d9c8";
defparam \mem[1][14] .operation_mode = "normal";
defparam \mem[1][14] .output_mode = "comb_only";
defparam \mem[1][14] .register_cascade_mode = "off";
defparam \mem[1][14] .sum_lutc_input = "qfbk";
defparam \mem[1][14] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X5_Y2_N0
maxv_lcell \mem[2][14] (
// Equation(s):
// \Mux1~3  = (\rd_addr~combout [1] & ((\Mux1~2  & (\mem[3][14]~regout )) # (!\Mux1~2  & ((mem[2][14]))))) # (!\rd_addr~combout [1] & (((\Mux1~2 ))))

	.clk(\wr_clk~combout ),
	.dataa(\rd_addr~combout [1]),
	.datab(\mem[3][14]~regout ),
	.datac(\data_in~combout [14]),
	.datad(\Mux1~2 ),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~4_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(\Mux1~3 ),
	.regout(\mem[2][14]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[2][14] .lut_mask = "dda0";
defparam \mem[2][14] .operation_mode = "normal";
defparam \mem[2][14] .output_mode = "comb_only";
defparam \mem[2][14] .register_cascade_mode = "off";
defparam \mem[2][14] .sum_lutc_input = "qfbk";
defparam \mem[2][14] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X5_Y2_N1
maxv_lcell \data_out[14]~reg0 (
// Equation(s):
// \data_out[14]~reg0_regout  = DFFEAS(((\rd_addr~combout [2] & (\Mux1~1 )) # (!\rd_addr~combout [2] & ((\Mux1~3 )))), GLOBAL(\rd_clk~combout ), !GLOBAL(\clr~combout ), , \re~combout , , , , )

	.clk(\rd_clk~combout ),
	.dataa(vcc),
	.datab(\rd_addr~combout [2]),
	.datac(\Mux1~1 ),
	.datad(\Mux1~3 ),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(\re~combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\data_out[14]~reg0_regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \data_out[14]~reg0 .lut_mask = "f3c0";
defparam \data_out[14]~reg0 .operation_mode = "normal";
defparam \data_out[14]~reg0 .output_mode = "reg_only";
defparam \data_out[14]~reg0 .register_cascade_mode = "off";
defparam \data_out[14]~reg0 .sum_lutc_input = "datac";
defparam \data_out[14]~reg0 .synch_mode = "off";
// synopsys translate_on

// Location: PIN_B1,	 I/O Standard: 3.3-V LVTTL,	 Current Strength: Default
maxv_io \data_in[15]~I (
	.datain(gnd),
	.oe(gnd),
	.combout(\data_in~combout [15]),
	.padio(data_in[15]));
// synopsys translate_off
defparam \data_in[15]~I .operation_mode = "input";
// synopsys translate_on

// Location: LC_X3_Y1_N4
maxv_lcell \mem[7][15] (
// Equation(s):
// \mem[7][15]~regout  = DFFEAS(GND, GLOBAL(\wr_clk~combout ), !GLOBAL(\clr~combout ), , \Decoder0~3_combout , \data_in~combout [15], , , VCC)

	.clk(\wr_clk~combout ),
	.dataa(vcc),
	.datab(vcc),
	.datac(\data_in~combout [15]),
	.datad(vcc),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~3_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\mem[7][15]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[7][15] .lut_mask = "0000";
defparam \mem[7][15] .operation_mode = "normal";
defparam \mem[7][15] .output_mode = "reg_only";
defparam \mem[7][15] .register_cascade_mode = "off";
defparam \mem[7][15] .sum_lutc_input = "datac";
defparam \mem[7][15] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X3_Y1_N8
maxv_lcell \mem[4][15] (
// Equation(s):
// \mem[4][15]~regout  = DFFEAS(GND, GLOBAL(\wr_clk~combout ), !GLOBAL(\clr~combout ), , \Decoder0~2_combout , \data_in~combout [15], , , VCC)

	.clk(\wr_clk~combout ),
	.dataa(vcc),
	.datab(vcc),
	.datac(\data_in~combout [15]),
	.datad(vcc),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~2_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\mem[4][15]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[4][15] .lut_mask = "0000";
defparam \mem[4][15] .operation_mode = "normal";
defparam \mem[4][15] .output_mode = "reg_only";
defparam \mem[4][15] .register_cascade_mode = "off";
defparam \mem[4][15] .sum_lutc_input = "datac";
defparam \mem[4][15] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X2_Y1_N2
maxv_lcell \mem[6][15] (
// Equation(s):
// \Mux0~0  = (\rd_addr~combout [1] & ((\rd_addr~combout [0]) # ((mem[6][15])))) # (!\rd_addr~combout [1] & (!\rd_addr~combout [0] & ((\mem[4][15]~regout ))))

	.clk(\wr_clk~combout ),
	.dataa(\rd_addr~combout [1]),
	.datab(\rd_addr~combout [0]),
	.datac(\data_in~combout [15]),
	.datad(\mem[4][15]~regout ),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~1_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(\Mux0~0 ),
	.regout(\mem[6][15]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[6][15] .lut_mask = "b9a8";
defparam \mem[6][15] .operation_mode = "normal";
defparam \mem[6][15] .output_mode = "comb_only";
defparam \mem[6][15] .register_cascade_mode = "off";
defparam \mem[6][15] .sum_lutc_input = "qfbk";
defparam \mem[6][15] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X2_Y1_N3
maxv_lcell \mem[5][15] (
// Equation(s):
// \Mux0~1  = (\rd_addr~combout [0] & ((\Mux0~0  & (\mem[7][15]~regout )) # (!\Mux0~0  & ((mem[5][15]))))) # (!\rd_addr~combout [0] & (((\Mux0~0 ))))

	.clk(\wr_clk~combout ),
	.dataa(\rd_addr~combout [0]),
	.datab(\mem[7][15]~regout ),
	.datac(\data_in~combout [15]),
	.datad(\Mux0~0 ),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~0_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(\Mux0~1 ),
	.regout(\mem[5][15]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[5][15] .lut_mask = "dda0";
defparam \mem[5][15] .operation_mode = "normal";
defparam \mem[5][15] .output_mode = "comb_only";
defparam \mem[5][15] .register_cascade_mode = "off";
defparam \mem[5][15] .sum_lutc_input = "qfbk";
defparam \mem[5][15] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X4_Y4_N9
maxv_lcell \mem[3][15] (
// Equation(s):
// \mem[3][15]~regout  = DFFEAS(GND, GLOBAL(\wr_clk~combout ), !GLOBAL(\clr~combout ), , \Decoder0~7_combout , \data_in~combout [15], , , VCC)

	.clk(\wr_clk~combout ),
	.dataa(vcc),
	.datab(vcc),
	.datac(\data_in~combout [15]),
	.datad(vcc),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~7_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\mem[3][15]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[3][15] .lut_mask = "0000";
defparam \mem[3][15] .operation_mode = "normal";
defparam \mem[3][15] .output_mode = "reg_only";
defparam \mem[3][15] .register_cascade_mode = "off";
defparam \mem[3][15] .sum_lutc_input = "datac";
defparam \mem[3][15] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X7_Y2_N4
maxv_lcell \mem[0][15] (
// Equation(s):
// \mem[0][15]~regout  = DFFEAS(GND, GLOBAL(\wr_clk~combout ), !GLOBAL(\clr~combout ), , \Decoder0~6_combout , \data_in~combout [15], , , VCC)

	.clk(\wr_clk~combout ),
	.dataa(vcc),
	.datab(vcc),
	.datac(\data_in~combout [15]),
	.datad(vcc),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~6_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\mem[0][15]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[0][15] .lut_mask = "0000";
defparam \mem[0][15] .operation_mode = "normal";
defparam \mem[0][15] .output_mode = "reg_only";
defparam \mem[0][15] .register_cascade_mode = "off";
defparam \mem[0][15] .sum_lutc_input = "datac";
defparam \mem[0][15] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X6_Y2_N9
maxv_lcell \mem[1][15] (
// Equation(s):
// \Mux0~2  = (\rd_addr~combout [1] & (\rd_addr~combout [0])) # (!\rd_addr~combout [1] & ((\rd_addr~combout [0] & (mem[1][15])) # (!\rd_addr~combout [0] & ((\mem[0][15]~regout )))))

	.clk(\wr_clk~combout ),
	.dataa(\rd_addr~combout [1]),
	.datab(\rd_addr~combout [0]),
	.datac(\data_in~combout [15]),
	.datad(\mem[0][15]~regout ),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~5_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(\Mux0~2 ),
	.regout(\mem[1][15]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[1][15] .lut_mask = "d9c8";
defparam \mem[1][15] .operation_mode = "normal";
defparam \mem[1][15] .output_mode = "comb_only";
defparam \mem[1][15] .register_cascade_mode = "off";
defparam \mem[1][15] .sum_lutc_input = "qfbk";
defparam \mem[1][15] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X5_Y1_N3
maxv_lcell \mem[2][15] (
// Equation(s):
// \Mux0~3  = (\rd_addr~combout [1] & ((\Mux0~2  & (\mem[3][15]~regout )) # (!\Mux0~2  & ((mem[2][15]))))) # (!\rd_addr~combout [1] & (((\Mux0~2 ))))

	.clk(\wr_clk~combout ),
	.dataa(\rd_addr~combout [1]),
	.datab(\mem[3][15]~regout ),
	.datac(\data_in~combout [15]),
	.datad(\Mux0~2 ),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(vcc),
	.ena(\Decoder0~4_combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(\Mux0~3 ),
	.regout(\mem[2][15]~regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \mem[2][15] .lut_mask = "dda0";
defparam \mem[2][15] .operation_mode = "normal";
defparam \mem[2][15] .output_mode = "comb_only";
defparam \mem[2][15] .register_cascade_mode = "off";
defparam \mem[2][15] .sum_lutc_input = "qfbk";
defparam \mem[2][15] .synch_mode = "on";
// synopsys translate_on

// Location: LC_X5_Y1_N0
maxv_lcell \data_out[15]~reg0 (
// Equation(s):
// \data_out[15]~reg0_regout  = DFFEAS(((\rd_addr~combout [2] & (\Mux0~1 )) # (!\rd_addr~combout [2] & ((\Mux0~3 )))), GLOBAL(\rd_clk~combout ), !GLOBAL(\clr~combout ), , \re~combout , , , , )

	.clk(\rd_clk~combout ),
	.dataa(vcc),
	.datab(\rd_addr~combout [2]),
	.datac(\Mux0~1 ),
	.datad(\Mux0~3 ),
	.aclr(\clr~combout ),
	.aload(gnd),
	.sclr(gnd),
	.sload(gnd),
	.ena(\re~combout ),
	.cin(gnd),
	.cin0(gnd),
	.cin1(vcc),
	.inverta(gnd),
	.regcascin(gnd),
	.devclrn(devclrn),
	.devpor(devpor),
	.combout(),
	.regout(\data_out[15]~reg0_regout ),
	.cout(),
	.cout0(),
	.cout1());
// synopsys translate_off
defparam \data_out[15]~reg0 .lut_mask = "f3c0";
defparam \data_out[15]~reg0 .operation_mode = "normal";
defparam \data_out[15]~reg0 .output_mode = "reg_only";
defparam \data_out[15]~reg0 .register_cascade_mode = "off";
defparam \data_out[15]~reg0 .sum_lutc_input = "datac";
defparam \data_out[15]~reg0 .synch_mode = "off";
// synopsys translate_on

// Location: PIN_B6,	 I/O Standard: 3.3-V LVTTL,	 Current Strength: 16mA
maxv_io \data_out[0]~I (
	.datain(\data_out[0]~reg0_regout ),
	.oe(vcc),
	.combout(),
	.padio(data_out[0]));
// synopsys translate_off
defparam \data_out[0]~I .operation_mode = "output";
// synopsys translate_on

// Location: PIN_D9,	 I/O Standard: 3.3-V LVTTL,	 Current Strength: 16mA
maxv_io \data_out[1]~I (
	.datain(\data_out[1]~reg0_regout ),
	.oe(vcc),
	.combout(),
	.padio(data_out[1]));
// synopsys translate_off
defparam \data_out[1]~I .operation_mode = "output";
// synopsys translate_on

// Location: PIN_B8,	 I/O Standard: 3.3-V LVTTL,	 Current Strength: 16mA
maxv_io \data_out[2]~I (
	.datain(\data_out[2]~reg0_regout ),
	.oe(vcc),
	.combout(),
	.padio(data_out[2]));
// synopsys translate_off
defparam \data_out[2]~I .operation_mode = "output";
// synopsys translate_on

// Location: PIN_A5,	 I/O Standard: 3.3-V LVTTL,	 Current Strength: 16mA
maxv_io \data_out[3]~I (
	.datain(\data_out[3]~reg0_regout ),
	.oe(vcc),
	.combout(),
	.padio(data_out[3]));
// synopsys translate_off
defparam \data_out[3]~I .operation_mode = "output";
// synopsys translate_on

// Location: PIN_A7,	 I/O Standard: 3.3-V LVTTL,	 Current Strength: 16mA
maxv_io \data_out[4]~I (
	.datain(\data_out[4]~reg0_regout ),
	.oe(vcc),
	.combout(),
	.padio(data_out[4]));
// synopsys translate_off
defparam \data_out[4]~I .operation_mode = "output";
// synopsys translate_on

// Location: PIN_K6,	 I/O Standard: 3.3-V LVTTL,	 Current Strength: 16mA
maxv_io \data_out[5]~I (
	.datain(\data_out[5]~reg0_regout ),
	.oe(vcc),
	.combout(),
	.padio(data_out[5]));
// synopsys translate_off
defparam \data_out[5]~I .operation_mode = "output";
// synopsys translate_on

// Location: PIN_J6,	 I/O Standard: 3.3-V LVTTL,	 Current Strength: 16mA
maxv_io \data_out[6]~I (
	.datain(\data_out[6]~reg0_regout ),
	.oe(vcc),
	.combout(),
	.padio(data_out[6]));
// synopsys translate_off
defparam \data_out[6]~I .operation_mode = "output";
// synopsys translate_on

// Location: PIN_J7,	 I/O Standard: 3.3-V LVTTL,	 Current Strength: 16mA
maxv_io \data_out[7]~I (
	.datain(\data_out[7]~reg0_regout ),
	.oe(vcc),
	.combout(),
	.padio(data_out[7]));
// synopsys translate_off
defparam \data_out[7]~I .operation_mode = "output";
// synopsys translate_on

// Location: PIN_K7,	 I/O Standard: 3.3-V LVTTL,	 Current Strength: 16mA
maxv_io \data_out[8]~I (
	.datain(\data_out[8]~reg0_regout ),
	.oe(vcc),
	.combout(),
	.padio(data_out[8]));
// synopsys translate_off
defparam \data_out[8]~I .operation_mode = "output";
// synopsys translate_on

// Location: PIN_C7,	 I/O Standard: 3.3-V LVTTL,	 Current Strength: 16mA
maxv_io \data_out[9]~I (
	.datain(\data_out[9]~reg0_regout ),
	.oe(vcc),
	.combout(),
	.padio(data_out[9]));
// synopsys translate_off
defparam \data_out[9]~I .operation_mode = "output";
// synopsys translate_on

// Location: PIN_H11,	 I/O Standard: 3.3-V LVTTL,	 Current Strength: 16mA
maxv_io \data_out[10]~I (
	.datain(\data_out[10]~reg0_regout ),
	.oe(vcc),
	.combout(),
	.padio(data_out[10]));
// synopsys translate_off
defparam \data_out[10]~I .operation_mode = "output";
// synopsys translate_on

// Location: PIN_L9,	 I/O Standard: 3.3-V LVTTL,	 Current Strength: 16mA
maxv_io \data_out[11]~I (
	.datain(\data_out[11]~reg0_regout ),
	.oe(vcc),
	.combout(),
	.padio(data_out[11]));
// synopsys translate_off
defparam \data_out[11]~I .operation_mode = "output";
// synopsys translate_on

// Location: PIN_K8,	 I/O Standard: 3.3-V LVTTL,	 Current Strength: 16mA
maxv_io \data_out[12]~I (
	.datain(\data_out[12]~reg0_regout ),
	.oe(vcc),
	.combout(),
	.padio(data_out[12]));
// synopsys translate_off
defparam \data_out[12]~I .operation_mode = "output";
// synopsys translate_on

// Location: PIN_K9,	 I/O Standard: 3.3-V LVTTL,	 Current Strength: 16mA
maxv_io \data_out[13]~I (
	.datain(\data_out[13]~reg0_regout ),
	.oe(vcc),
	.combout(),
	.padio(data_out[13]));
// synopsys translate_off
defparam \data_out[13]~I .operation_mode = "output";
// synopsys translate_on

// Location: PIN_F9,	 I/O Standard: 3.3-V LVTTL,	 Current Strength: 16mA
maxv_io \data_out[14]~I (
	.datain(\data_out[14]~reg0_regout ),
	.oe(vcc),
	.combout(),
	.padio(data_out[14]));
// synopsys translate_off
defparam \data_out[14]~I .operation_mode = "output";
// synopsys translate_on

// Location: PIN_L8,	 I/O Standard: 3.3-V LVTTL,	 Current Strength: 16mA
maxv_io \data_out[15]~I (
	.datain(\data_out[15]~reg0_regout ),
	.oe(vcc),
	.combout(),
	.padio(data_out[15]));
// synopsys translate_off
defparam \data_out[15]~I .operation_mode = "output";
// synopsys translate_on

endmodule
